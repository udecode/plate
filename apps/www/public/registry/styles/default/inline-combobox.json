{
  "dependencies": [
    "@ariakit/react",
    "@udecode/plate-combobox"
  ],
  "files": [
    {
      "content": "import React, {\n  type HTMLAttributes,\n  type ReactNode,\n  type RefObject,\n  createContext,\n  forwardRef,\n  startTransition,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\n\nimport type { PointRef } from 'slate';\n\nimport {\n  type ComboboxItemProps,\n  Combobox,\n  ComboboxItem,\n  ComboboxPopover,\n  ComboboxProvider,\n  Portal,\n  useComboboxContext,\n  useComboboxStore,\n} from '@ariakit/react';\nimport { cn } from '@udecode/cn';\nimport { filterWords } from '@udecode/plate-combobox';\nimport {\n  type UseComboboxInputResult,\n  useComboboxInput,\n  useHTMLInputCursorState,\n} from '@udecode/plate-combobox/react';\nimport {\n  type TElement,\n  createPointRef,\n  getPointBefore,\n  insertText,\n  moveSelection,\n} from '@udecode/plate-common';\nimport {\n  findNodePath,\n  useComposedRef,\n  useEditorRef,\n} from '@udecode/plate-common/react';\nimport { cva } from 'class-variance-authority';\n\ntype FilterFn = (\n  item: { value: string; keywords?: string[] },\n  search: string\n) => boolean;\n\ninterface InlineComboboxContextValue {\n  filter: FilterFn | false;\n  inputProps: UseComboboxInputResult['props'];\n  inputRef: RefObject<HTMLInputElement>;\n  removeInput: UseComboboxInputResult['removeInput'];\n  setHasEmpty: (hasEmpty: boolean) => void;\n  showTrigger: boolean;\n  trigger: string;\n}\n\nconst InlineComboboxContext = createContext<InlineComboboxContextValue>(\n  null as any\n);\n\nexport const defaultFilter: FilterFn = ({ keywords = [], value }, search) =>\n  [value, ...keywords].some((keyword) => filterWords(keyword, search));\n\ninterface InlineComboboxProps {\n  children: ReactNode;\n  element: TElement;\n  trigger: string;\n  filter?: FilterFn | false;\n  hideWhenNoValue?: boolean;\n  setValue?: (value: string) => void;\n  showTrigger?: boolean;\n  value?: string;\n}\n\nconst InlineCombobox = ({\n  children,\n  element,\n  filter = defaultFilter,\n  hideWhenNoValue = false,\n  setValue: setValueProp,\n  showTrigger = true,\n  trigger,\n  value: valueProp,\n}: InlineComboboxProps) => {\n  const editor = useEditorRef();\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const cursorState = useHTMLInputCursorState(inputRef);\n\n  const [valueState, setValueState] = useState('');\n  const hasValueProp = valueProp !== undefined;\n  const value = hasValueProp ? valueProp : valueState;\n\n  const setValue = useCallback(\n    (newValue: string) => {\n      setValueProp?.(newValue);\n\n      if (!hasValueProp) {\n        setValueState(newValue);\n      }\n    },\n    [setValueProp, hasValueProp]\n  );\n\n  /**\n   * Track the point just before the input element so we know where to\n   * insertText if the combobox closes due to a selection change.\n   */\n  const [insertPoint, setInsertPoint] = useState<PointRef | null>(null);\n\n  useEffect(() => {\n    const path = findNodePath(editor, element);\n\n    if (!path) return;\n\n    const point = getPointBefore(editor, path);\n\n    if (!point) return;\n\n    const pointRef = createPointRef(editor, point);\n    setInsertPoint(pointRef);\n\n    return () => {\n      pointRef.unref();\n    };\n  }, [editor, element]);\n\n  const { props: inputProps, removeInput } = useComboboxInput({\n    cancelInputOnBlur: false,\n    cursorState,\n    ref: inputRef,\n    onCancelInput: (cause) => {\n      if (cause !== 'backspace') {\n        insertText(editor, trigger + value, {\n          at: insertPoint?.current ?? undefined,\n        });\n      }\n      if (cause === 'arrowLeft' || cause === 'arrowRight') {\n        moveSelection(editor, {\n          distance: 1,\n          reverse: cause === 'arrowLeft',\n        });\n      }\n    },\n  });\n\n  const [hasEmpty, setHasEmpty] = useState(false);\n\n  const contextValue: InlineComboboxContextValue = useMemo(\n    () => ({\n      filter,\n      inputProps,\n      inputRef,\n      removeInput,\n      setHasEmpty,\n      showTrigger,\n      trigger,\n    }),\n    [\n      trigger,\n      showTrigger,\n      filter,\n      inputRef,\n      inputProps,\n      removeInput,\n      setHasEmpty,\n    ]\n  );\n\n  const store = useComboboxStore({\n    // open: ,\n    setValue: (newValue) => startTransition(() => setValue(newValue)),\n  });\n\n  const items = store.useState('items');\n\n  /**\n   * If there is no active ID and the list of items changes, select the first\n   * item.\n   */\n  useEffect(() => {\n    if (!store.getState().activeId) {\n      store.setActiveId(store.first());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [items, store]);\n\n  return (\n    <span contentEditable={false}>\n      <ComboboxProvider\n        open={\n          (items.length > 0 || hasEmpty) &&\n          (!hideWhenNoValue || value.length > 0)\n        }\n        store={store}\n      >\n        <InlineComboboxContext.Provider value={contextValue}>\n          {children}\n        </InlineComboboxContext.Provider>\n      </ComboboxProvider>\n    </span>\n  );\n};\n\nconst InlineComboboxInput = forwardRef<\n  HTMLInputElement,\n  HTMLAttributes<HTMLInputElement>\n>(({ className, ...props }, propRef) => {\n  const {\n    inputProps,\n    inputRef: contextRef,\n    showTrigger,\n    trigger,\n  } = useContext(InlineComboboxContext);\n\n  const store = useComboboxContext()!;\n  const value = store.useState('value');\n\n  const ref = useComposedRef(propRef, contextRef);\n\n  /**\n   * To create an auto-resizing input, we render a visually hidden span\n   * containing the input value and position the input element on top of it.\n   * This works well for all cases except when input exceeds the width of the\n   * container.\n   */\n\n  return (\n    <>\n      {showTrigger && trigger}\n\n      <span className=\"relative min-h-[1lh]\">\n        <span\n          className=\"invisible overflow-hidden text-nowrap\"\n          aria-hidden=\"true\"\n        >\n          {value || '\\u200B'}\n        </span>\n\n        <Combobox\n          ref={ref}\n          className={cn(\n            'absolute left-0 top-0 size-full bg-transparent outline-none',\n            className\n          )}\n          value={value}\n          autoSelect\n          {...inputProps}\n          {...props}\n        />\n      </span>\n    </>\n  );\n});\n\nInlineComboboxInput.displayName = 'InlineComboboxInput';\n\nconst InlineComboboxContent: typeof ComboboxPopover = ({\n  className,\n  ...props\n}) => {\n  // Portal prevents CSS from leaking into popover\n  return (\n    <Portal>\n      <ComboboxPopover\n        className={cn(\n          'z-[500] max-h-[288px] w-[300px] overflow-y-auto rounded-md bg-popover shadow-md',\n          className\n        )}\n        {...props}\n      />\n    </Portal>\n  );\n};\n\nconst comboboxItemVariants = cva(\n  'relative flex h-9 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none',\n  {\n    defaultVariants: {\n      interactive: true,\n    },\n    variants: {\n      interactive: {\n        false: '',\n        true: 'cursor-pointer transition-colors hover:bg-accent hover:text-accent-foreground data-[active-item=true]:bg-accent data-[active-item=true]:text-accent-foreground',\n      },\n    },\n  }\n);\n\nexport type InlineComboboxItemProps = {\n  keywords?: string[];\n} & ComboboxItemProps &\n  Required<Pick<ComboboxItemProps, 'value'>>;\n\nconst InlineComboboxItem = ({\n  className,\n  keywords,\n  onClick,\n  ...props\n}: InlineComboboxItemProps) => {\n  const { value } = props;\n\n  const { filter, removeInput } = useContext(InlineComboboxContext);\n\n  const store = useComboboxContext()!;\n\n  // Optimization: Do not subscribe to value if filter is false\n  const search = filter && store.useState('value');\n\n  const visible = useMemo(\n    () => !filter || filter({ keywords, value }, search as string),\n    [filter, value, keywords, search]\n  );\n\n  if (!visible) return null;\n\n  return (\n    <ComboboxItem\n      className={cn(comboboxItemVariants(), className)}\n      onClick={(event) => {\n        removeInput(true);\n        onClick?.(event);\n      }}\n      {...props}\n    />\n  );\n};\n\nconst InlineComboboxEmpty = ({\n  children,\n  className,\n}: HTMLAttributes<HTMLDivElement>) => {\n  const { setHasEmpty } = useContext(InlineComboboxContext);\n  const store = useComboboxContext()!;\n  const items = store.useState('items');\n\n  useEffect(() => {\n    setHasEmpty(true);\n\n    return () => {\n      setHasEmpty(false);\n    };\n  }, [setHasEmpty]);\n\n  if (items.length > 0) return null;\n\n  return (\n    <div\n      className={cn(comboboxItemVariants({ interactive: false }), className)}\n    >\n      {children}\n    </div>\n  );\n};\n\nexport {\n  InlineCombobox,\n  InlineComboboxContent,\n  InlineComboboxEmpty,\n  InlineComboboxInput,\n  InlineComboboxItem,\n};\n",
      "name": "inline-combobox.tsx"
    }
  ],
  "name": "inline-combobox",
  "registryDependencies": [],
  "type": "components:plate-ui"
}