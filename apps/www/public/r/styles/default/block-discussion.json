{
  "dependencies": [
    "@udecode/plate-comments",
    "date-fns"
  ],
  "doc": {
    "description": "A popover interface for managing discussions: comments, replies, suggestions.",
    "docs": [
      {
        "route": "/docs/comments"
      },
      {
        "route": "https://pro.platejs.org/docs/components/block-discussion"
      }
    ],
    "examples": [
      "comments-demo",
      "comments-pro"
    ]
  },
  "files": [
    {
      "path": "plate-ui/block-discussion.tsx",
      "content": "'use client';\n\nimport React, { useMemo } from 'react';\n\nimport type { TSuggestionText } from '@udecode/plate-suggestion';\nimport type {\n  PlateRenderElementProps,\n  RenderNodeWrapper,\n} from '@udecode/plate/react';\n\nimport {\n  type NodeEntry,\n  type Path,\n  type TElement,\n  createZustandStore,\n  PathApi,\n  TextApi,\n} from '@udecode/plate';\nimport { type TCommentText, getDraftCommentKey } from '@udecode/plate-comments';\nimport { CommentsPlugin } from '@udecode/plate-comments/react';\nimport { SuggestionPlugin } from '@udecode/plate-suggestion/react';\nimport {\n  useEditorPlugin,\n  useEditorRef,\n  usePluginOption,\n  useStoreValue,\n} from '@udecode/plate/react';\nimport {\n  MessageSquareTextIcon,\n  MessagesSquareIcon,\n  PencilLineIcon,\n} from 'lucide-react';\n\nimport {\n  type CommentsConfig,\n  commentsPlugin,\n} from '@/components/editor/plugins/comments-plugin';\nimport { suggestionPlugin } from '@/components/editor/plugins/suggestion-plugin';\nimport { Button } from '@/components/plate-ui/button';\nimport {\n  Popover,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/plate-ui/popover';\n\nimport {\n  BlockSuggestionCard,\n  isResolvedSuggestion,\n  useResolveSuggestion,\n} from './block-suggestion';\nimport { type TComment, Comment } from './comment';\nimport { CommentCreateForm } from './comment-create-form';\n\nexport interface TDiscussion {\n  id: string;\n  comments: TComment[];\n  createdAt: Date;\n  isResolved: boolean;\n  userId: string;\n  documentContent?: string;\n}\n\nconst initTestDiscussions = [\n  {\n    id: 'discussion1',\n    comments: [\n      {\n        id: 'comment1',\n        contentRich: [\n          {\n            children: [\n              {\n                text: 'This is a comment',\n              },\n            ],\n            type: 'p',\n          },\n        ],\n        createdAt: new Date(Date.now() - 900_000),\n        discussionId: 'discussion1',\n        isEdited: false,\n        userId: 'user1',\n      },\n    ],\n    createdAt: new Date(),\n    documentContent: 'comments to your content',\n    isResolved: false,\n    userId: 'user1',\n  },\n  {\n    id: 'discussion2',\n    comments: [\n      {\n        id: 'comment1',\n        contentRich: [\n          {\n            children: [\n              {\n                text: 'Hey, what do you think about this approach?',\n              },\n            ],\n            type: 'p',\n          },\n        ],\n        createdAt: new Date(Date.now() - 900_000),\n        discussionId: 'discussion1',\n        isEdited: false,\n        userId: 'user1',\n      },\n      {\n        id: 'comment2',\n        contentRich: [\n          {\n            children: [\n              {\n                text: 'Looks good!',\n              },\n            ],\n            type: 'p',\n          },\n        ],\n        createdAt: new Date(Date.now() - 800_000),\n        discussionId: 'discussion1',\n        isEdited: false,\n        userId: 'user2',\n      },\n      {\n        id: 'comment3',\n        contentRich: [\n          {\n            children: [\n              {\n                text: 'Thanks for the feedback!',\n              },\n            ],\n            type: 'p',\n          },\n        ],\n        createdAt: new Date(Date.now() - 700_000),\n        discussionId: 'discussion1',\n        isEdited: false,\n        userId: 'user1',\n      },\n    ],\n    createdAt: new Date(),\n    documentContent: 'collaborate',\n    isResolved: false,\n    userId: 'user2',\n  },\n];\n\ntype TDiscussionStore = {\n  discussions: TDiscussion[];\n};\n\nexport const discussionStore = createZustandStore<TDiscussionStore>(\n  {\n    discussions: initTestDiscussions,\n  },\n  {\n    devtools: { enabled: true }, // Redux DevTools with options\n    mutative: true, // shorthand for { enabled: true }\n    name: 'discussion',\n  }\n);\n\nexport const useFakeCurrentUserId = () => 'user3';\n\nexport const useFakeUserInfo = (userId: string) => {\n  const mockUsers = [\n    {\n      id: 'user1',\n      avatarUrl: 'https://avatars.githubusercontent.com/u/19695832?s=96&v=4',\n      name: 'zbeyens',\n    },\n    {\n      id: 'user2',\n      avatarUrl: 'https://avatars.githubusercontent.com/u/4272090?v=4',\n      name: '12joan',\n    },\n    {\n      id: 'user3',\n      avatarUrl: 'https://avatars.githubusercontent.com/u/164472012?v=4',\n      name: 'felixfeng33',\n    },\n  ];\n\n  return mockUsers.find((user) => user.id === userId);\n};\n\nexport const BlockDiscussion: RenderNodeWrapper<CommentsConfig> = (props) => {\n  const { api, editor, element } = props;\n\n  const blockPath = editor.api.findPath(element);\n\n  // avoid duplicate in table or column\n  if (!blockPath || blockPath.length > 1) return;\n\n  const draftCommentNode = api.comment.node({ at: blockPath, isDraft: true });\n\n  const commentNodes = [...api.comment.nodes({ at: blockPath })];\n\n  const suggestionNodes = [\n    ...editor.getApi(SuggestionPlugin).suggestion.nodes({ at: blockPath }),\n  ];\n\n  if (\n    commentNodes.length === 0 &&\n    suggestionNodes.length === 0 &&\n    !draftCommentNode\n  ) {\n    return;\n  }\n\n  return (props) => (\n    <BlockCommentsContent\n      blockPath={blockPath}\n      commentNodes={commentNodes}\n      draftCommentNode={draftCommentNode}\n      suggestionNodes={suggestionNodes}\n      {...props}\n    />\n  );\n};\n\nconst BlockCommentsContent = ({\n  blockPath,\n  children,\n  commentNodes,\n  draftCommentNode,\n  suggestionNodes,\n}: PlateRenderElementProps & {\n  blockPath: Path;\n  commentNodes: NodeEntry<TCommentText>[];\n  draftCommentNode: NodeEntry<TCommentText> | undefined;\n  suggestionNodes: NodeEntry<TElement | TSuggestionText>[];\n}) => {\n  const editor = useEditorRef();\n\n  const resolvedSuggestion = useResolveSuggestion(suggestionNodes, blockPath);\n\n  const resolvedDiscussions = useResolvedDiscussion(commentNodes, blockPath);\n\n  const suggestionsCount = resolvedSuggestion.length;\n  const discussionsCount = resolvedDiscussions.length;\n  const totalCount = suggestionsCount + discussionsCount;\n\n  const activeSuggestionId = usePluginOption(suggestionPlugin, 'activeId');\n  const activeSuggestion =\n    activeSuggestionId &&\n    resolvedSuggestion.find((s) => s.suggestionId === activeSuggestionId);\n\n  const commentingBlock = usePluginOption(commentsPlugin, 'commentingBlock');\n  const activeCommentId = usePluginOption(commentsPlugin, 'activeId');\n  const isCommenting = activeCommentId === getDraftCommentKey();\n  const activeDiscussion =\n    activeCommentId &&\n    resolvedDiscussions.find((d) => d.id === activeCommentId);\n\n  const noneActive = !activeSuggestion && !activeDiscussion;\n\n  const sortedMergedData = [...resolvedDiscussions, ...resolvedSuggestion].sort(\n    (a, b) => a.createdAt.getTime() - b.createdAt.getTime()\n  );\n\n  const selected =\n    resolvedDiscussions.some((d) => d.id === activeCommentId) ||\n    resolvedSuggestion.some((s) => s.suggestionId === activeSuggestionId);\n\n  const [_open, setOpen] = React.useState(selected);\n\n  // in some cases, we may comment the multiple blocks\n  const commentingCurrent =\n    !!commentingBlock && PathApi.equals(blockPath, commentingBlock);\n\n  const open =\n    _open ||\n    selected ||\n    (isCommenting && !!draftCommentNode && commentingCurrent);\n\n  const anchorElement = useMemo(() => {\n    let activeNode: NodeEntry | undefined;\n\n    if (activeSuggestion) {\n      activeNode = suggestionNodes.find(\n        ([node]) =>\n          TextApi.isText(node) &&\n          editor.getApi(SuggestionPlugin).suggestion.nodeId(node) ===\n            activeSuggestion.suggestionId\n      );\n    }\n\n    if (activeCommentId) {\n      if (activeCommentId === getDraftCommentKey()) {\n        activeNode = draftCommentNode;\n      } else {\n        activeNode = commentNodes.find(\n          ([node]) =>\n            editor.getApi(CommentsPlugin).comment.nodeId(node) ===\n            activeCommentId\n        );\n      }\n    }\n\n    if (!activeNode) return null;\n\n    return editor.api.toDOMNode(activeNode[0])!;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    open,\n    activeSuggestion,\n    activeCommentId,\n    editor.api,\n    suggestionNodes,\n    draftCommentNode,\n    commentNodes,\n  ]);\n\n  if (suggestionsCount + resolvedDiscussions.length === 0 && !draftCommentNode)\n    return <div className=\"w-full\">{children}</div>;\n\n  return (\n    <div className=\"flex w-full justify-between\">\n      <Popover\n        open={open}\n        onOpenChange={(_open_) => {\n          if (!_open_ && isCommenting && draftCommentNode) {\n            editor.tf.unsetNodes(getDraftCommentKey(), {\n              at: [],\n              mode: 'lowest',\n              match: (n) => n[getDraftCommentKey()],\n            });\n          }\n          setOpen(_open_);\n        }}\n      >\n        <div className=\"w-full\">{children}</div>\n        {anchorElement && (\n          <PopoverAnchor\n            asChild\n            className=\"w-full\"\n            virtualRef={{ current: anchorElement }}\n          />\n        )}\n\n        <PopoverContent\n          className=\"max-h-[min(50dvh,calc(-24px+var(--radix-popper-available-height)))] w-[380px] max-w-[calc(100vw-24px)] min-w-[130px] overflow-y-auto p-0 data-[state=closed]:opacity-0\"\n          onCloseAutoFocus={(e) => e.preventDefault()}\n          onOpenAutoFocus={(e) => e.preventDefault()}\n          align=\"center\"\n          side=\"bottom\"\n        >\n          {isCommenting ? (\n            <CommentCreateForm className=\"p-4\" focusOnMount />\n          ) : (\n            <React.Fragment>\n              {noneActive ? (\n                sortedMergedData.map((item, index) =>\n                  isResolvedSuggestion(item) ? (\n                    <BlockSuggestionCard\n                      key={item.suggestionId}\n                      idx={index}\n                      isLast={index === sortedMergedData.length - 1}\n                      suggestion={item}\n                    />\n                  ) : (\n                    <BlockComment\n                      key={item.id}\n                      discussion={item}\n                      isLast={index === sortedMergedData.length - 1}\n                    />\n                  )\n                )\n              ) : (\n                <React.Fragment>\n                  {activeSuggestion && (\n                    <BlockSuggestionCard\n                      key={activeSuggestion.suggestionId}\n                      idx={0}\n                      isLast={true}\n                      suggestion={activeSuggestion}\n                    />\n                  )}\n\n                  {activeDiscussion && (\n                    <BlockComment discussion={activeDiscussion} isLast={true} />\n                  )}\n                </React.Fragment>\n              )}\n            </React.Fragment>\n          )}\n        </PopoverContent>\n\n        {totalCount > 0 && (\n          <div className=\"relative left-0 size-0 select-none\">\n            <PopoverTrigger asChild>\n              <Button\n                variant=\"ghost\"\n                className=\"mt-1 ml-1 flex h-6 gap-1 px-1.5 py-0 text-muted-foreground/80 hover:text-muted-foreground/80 data-[active=true]:bg-muted\"\n                data-active={open}\n                contentEditable={false}\n              >\n                {suggestionsCount > 0 && discussionsCount === 0 && (\n                  <PencilLineIcon className=\"size-4 shrink-0\" />\n                )}\n\n                {suggestionsCount === 0 && discussionsCount > 0 && (\n                  <MessageSquareTextIcon className=\"size-4 shrink-0\" />\n                )}\n\n                {suggestionsCount > 0 && discussionsCount > 0 && (\n                  <MessagesSquareIcon className=\"size-4 shrink-0\" />\n                )}\n\n                <span className=\"text-xs font-semibold\">{totalCount}</span>\n              </Button>\n            </PopoverTrigger>\n          </div>\n        )}\n      </Popover>\n    </div>\n  );\n};\n\nexport const BlockComment = ({\n  discussion,\n  isLast,\n}: {\n  discussion: TDiscussion;\n  isLast: boolean;\n}) => {\n  const [editingId, setEditingId] = React.useState<string | null>(null);\n\n  return (\n    <React.Fragment key={discussion.id}>\n      <div className=\"p-4\">\n        {discussion.comments.map((comment, index) => (\n          <Comment\n            key={comment.id ?? index}\n            comment={comment}\n            discussionLength={discussion.comments.length}\n            documentContent={discussion?.documentContent}\n            editingId={editingId}\n            index={index}\n            setEditingId={setEditingId}\n            showDocumentContent\n          />\n        ))}\n        <CommentCreateForm discussionId={discussion.id} />\n      </div>\n\n      {!isLast && <div className=\"h-px w-full bg-muted\" />}\n    </React.Fragment>\n  );\n};\n\nexport const useResolvedDiscussion = (\n  commentNodes: NodeEntry<TCommentText>[],\n  blockPath: Path\n) => {\n  const { api, getOption, setOption } = useEditorPlugin(commentsPlugin);\n\n  const discussions = useStoreValue(discussionStore, 'discussions');\n\n  commentNodes.forEach(([node]) => {\n    const id = api.comment.nodeId(node);\n    const map = getOption('uniquePathMap');\n\n    if (!id) return;\n\n    const previousPath = map.get(id);\n\n    // If there are no comment nodes in the corresponding path in the map, then update it.\n    if (PathApi.isPath(previousPath)) {\n      const nodes = api.comment.node({ id, at: previousPath });\n\n      if (!nodes) {\n        setOption('uniquePathMap', new Map(map).set(id, blockPath));\n        return;\n      }\n\n      return;\n    }\n    // TODO: fix throw error\n    setOption('uniquePathMap', new Map(map).set(id, blockPath));\n  });\n\n  const commentsIds = new Set(\n    commentNodes.map(([node]) => api.comment.nodeId(node)).filter(Boolean)\n  );\n\n  const resolvedDiscussions = discussions\n    .map((d: TDiscussion) => ({\n      ...d,\n      createdAt: new Date(d.createdAt),\n    }))\n    .filter((item: TDiscussion) => {\n      /** If comment cross blocks just show it in the first block */\n      const commentsPathMap = getOption('uniquePathMap');\n      const firstBlockPath = commentsPathMap.get(item.id);\n\n      if (!firstBlockPath) return false;\n      if (!PathApi.equals(firstBlockPath, blockPath)) return false;\n\n      return (\n        api.comment.has({ id: item.id }) &&\n        commentsIds.has(item.id) &&\n        !item.isResolved\n      );\n    });\n\n  return resolvedDiscussions;\n};\n",
      "type": "registry:ui",
      "target": "components/plate-ui/block-discussion.tsx"
    },
    {
      "path": "plate-ui/block-suggestion.tsx",
      "content": "'use client';\n\nimport React, { useMemo, useState } from 'react';\n\nimport type {\n  TResolvedSuggestion,\n  TSuggestionElement,\n  TSuggestionText,\n} from '@udecode/plate-suggestion';\n\nimport { cn } from '@udecode/cn';\nimport {\n  type NodeEntry,\n  type Path,\n  type TElement,\n  ElementApi,\n  PathApi,\n  TextApi,\n} from '@udecode/plate';\nimport { BlockquotePlugin } from '@udecode/plate-block-quote/react';\nimport { CalloutPlugin } from '@udecode/plate-callout/react';\nimport { CodeBlockPlugin } from '@udecode/plate-code-block/react';\nimport { HEADING_KEYS } from '@udecode/plate-heading';\nimport { TocPlugin } from '@udecode/plate-heading/react';\nimport { HorizontalRulePlugin } from '@udecode/plate-horizontal-rule/react';\nimport { INDENT_LIST_KEYS, ListStyleType } from '@udecode/plate-indent-list';\nimport { IndentListPlugin } from '@udecode/plate-indent-list/react';\nimport { ColumnPlugin } from '@udecode/plate-layout/react';\nimport { EquationPlugin } from '@udecode/plate-math/react';\nimport {\n  AudioPlugin,\n  FilePlugin,\n  ImagePlugin,\n  MediaEmbedPlugin,\n  VideoPlugin,\n} from '@udecode/plate-media/react';\nimport {\n  acceptSuggestion,\n  getSuggestionKey,\n  keyId2SuggestionId,\n  rejectSuggestion,\n} from '@udecode/plate-suggestion';\nimport { SuggestionPlugin } from '@udecode/plate-suggestion/react';\nimport { TablePlugin } from '@udecode/plate-table/react';\nimport { TogglePlugin } from '@udecode/plate-toggle/react';\nimport {\n  ParagraphPlugin,\n  useEditorPlugin,\n  useStoreSelect,\n} from '@udecode/plate/react';\nimport { CheckIcon, XIcon } from 'lucide-react';\n\nimport { suggestionPlugin } from '@/components/editor/plugins/suggestion-plugin';\n\nimport { Avatar, AvatarFallback, AvatarImage } from './avatar';\nimport {\n  type TDiscussion,\n  discussionStore,\n  useFakeUserInfo,\n} from './block-discussion';\nimport { Button } from './button';\nimport { type TComment, Comment, formatCommentDate } from './comment';\nimport { CommentCreateForm } from './comment-create-form';\n\nexport interface ResolvedSuggestion extends TResolvedSuggestion {\n  comments: TComment[];\n}\n\nexport const BLOCK_SUGGESTION = '__block__';\n\nexport const TYPE_TEXT_MAP: Record<string, (node?: TElement) => string> = {\n  [AudioPlugin.key]: () => 'Audio',\n  [BlockquotePlugin.key]: () => 'Blockquote',\n  [CalloutPlugin.key]: () => 'Callout',\n  [CodeBlockPlugin.key]: () => 'Code Block',\n  [ColumnPlugin.key]: () => 'Column',\n  [EquationPlugin.key]: () => 'Equation',\n  [FilePlugin.key]: () => 'File',\n  [HEADING_KEYS.h1]: () => `Heading 1`,\n  [HEADING_KEYS.h2]: () => `Heading 2`,\n  [HEADING_KEYS.h3]: () => `Heading 3`,\n  [HEADING_KEYS.h4]: () => `Heading 4`,\n  [HEADING_KEYS.h5]: () => `Heading 5`,\n  [HEADING_KEYS.h6]: () => `Heading 6`,\n  [HorizontalRulePlugin.key]: () => 'Horizontal Rule',\n  [ImagePlugin.key]: () => 'Image',\n  [MediaEmbedPlugin.key]: () => 'Media',\n  [ParagraphPlugin.key]: (node) => {\n    if (node?.[IndentListPlugin.key] === INDENT_LIST_KEYS.todo)\n      return 'Todo List';\n    if (node?.[IndentListPlugin.key] === ListStyleType.Decimal)\n      return 'Ordered List';\n    if (node?.[IndentListPlugin.key] === ListStyleType.Disc) return 'List';\n\n    return 'Paragraph';\n  },\n  [TablePlugin.key]: () => 'Table',\n  [TocPlugin.key]: () => 'Table of Contents',\n  [TogglePlugin.key]: () => 'Toggle',\n  [VideoPlugin.key]: () => 'Video',\n};\n\nexport const BlockSuggestionCard = ({\n  idx,\n  isLast,\n  suggestion,\n}: {\n  idx: number;\n  isLast: boolean;\n  suggestion: ResolvedSuggestion;\n}) => {\n  const { api, editor } = useEditorPlugin(SuggestionPlugin);\n\n  const userInfo = useFakeUserInfo(suggestion.userId);\n\n  const accept = (suggestion: ResolvedSuggestion) => {\n    api.suggestion.withoutSuggestions(() => {\n      acceptSuggestion(editor, suggestion);\n    });\n  };\n\n  const reject = (suggestion: ResolvedSuggestion) => {\n    api.suggestion.withoutSuggestions(() => {\n      rejectSuggestion(editor, suggestion);\n    });\n  };\n\n  const [hovering, setHovering] = useState(false);\n\n  const suggestionText2Array = (text: string) => {\n    if (text === BLOCK_SUGGESTION) return ['line breaks'];\n\n    return text.split(BLOCK_SUGGESTION).filter(Boolean);\n  };\n\n  const [editingId, setEditingId] = useState<string | null>(null);\n\n  return (\n    <div\n      key={`${suggestion.suggestionId}-${idx}`}\n      className=\"relative\"\n      onMouseEnter={() => setHovering(true)}\n      onMouseLeave={() => setHovering(false)}\n    >\n      <div className=\"flex flex-col p-4\">\n        <div className=\"relative flex items-center\">\n          {/* Replace to your own backend or refer to potion */}\n          <Avatar className=\"size-6\">\n            <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />\n            <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>\n          </Avatar>\n          <h4 className=\"mx-2 text-sm leading-none font-semibold\">\n            {userInfo?.name}\n          </h4>\n          <div className=\"text-xs leading-none text-muted-foreground/80\">\n            <span className=\"mr-1\">\n              {formatCommentDate(new Date(suggestion.createdAt))}\n            </span>\n          </div>\n        </div>\n\n        <div className=\"relative mt-1 mb-4 pl-[32px]\">\n          <div className=\"flex flex-col gap-2\">\n            {suggestion.type === 'remove' && (\n              <React.Fragment>\n                {suggestionText2Array(suggestion.text!).map((text, index) => (\n                  <div key={index} className=\"flex items-center gap-2\">\n                    <span className=\"text-sm text-muted-foreground\">\n                      Delete:\n                    </span>\n\n                    <span key={index} className=\"text-sm\">\n                      {text}\n                    </span>\n                  </div>\n                ))}\n              </React.Fragment>\n            )}\n\n            {suggestion.type === 'insert' && (\n              <React.Fragment>\n                {suggestionText2Array(suggestion.newText!).map(\n                  (text, index) => (\n                    <div key={index} className=\"flex items-center gap-2\">\n                      <span className=\"text-sm text-muted-foreground\">\n                        Add:\n                      </span>\n\n                      <span key={index} className=\"text-sm\">\n                        {text || 'line breaks'}\n                      </span>\n                    </div>\n                  )\n                )}\n              </React.Fragment>\n            )}\n\n            {suggestion.type === 'replace' && (\n              <div className=\"flex flex-col gap-2\">\n                {suggestionText2Array(suggestion.newText!).map(\n                  (text, index) => (\n                    <React.Fragment key={index}>\n                      <div\n                        key={index}\n                        className=\"flex items-start gap-2 text-brand/80\"\n                      >\n                        <span className=\"text-sm\">with:</span>\n                        <span className=\"text-sm\">{text || 'line breaks'}</span>\n                      </div>\n                    </React.Fragment>\n                  )\n                )}\n\n                {suggestionText2Array(suggestion.text!).map((text, index) => (\n                  <React.Fragment key={index}>\n                    <div key={index} className=\"flex items-start gap-2\">\n                      <span className=\"text-sm text-muted-foreground\">\n                        {index === 0 ? 'Replace:' : 'Delete:'}\n                      </span>\n                      <span className=\"text-sm\">{text || 'line breaks'}</span>\n                    </div>\n                  </React.Fragment>\n                ))}\n              </div>\n            )}\n\n            {suggestion.type === 'update' && (\n              <div className=\"flex items-center gap-2\">\n                <span className=\"text-sm text-muted-foreground\">\n                  {Object.keys(suggestion.properties).map((key) => (\n                    <span key={key}>Un{key}</span>\n                  ))}\n\n                  {Object.keys(suggestion.newProperties).map((key) => (\n                    <span key={key}>\n                      {key.charAt(0).toUpperCase() + key.slice(1)}\n                    </span>\n                  ))}\n                </span>\n                <span className=\"text-sm\">{suggestion.newText}</span>\n              </div>\n            )}\n          </div>\n        </div>\n\n        {suggestion.comments.map((comment, index) => (\n          <Comment\n            key={comment.id ?? index}\n            comment={comment}\n            discussionLength={suggestion.comments.length}\n            documentContent=\"__suggestion__\"\n            editingId={editingId}\n            index={index}\n            setEditingId={setEditingId}\n          />\n        ))}\n\n        {hovering && (\n          <div className=\"absolute top-4 right-4 flex gap-2\">\n            <Button\n              variant=\"ghost\"\n              className=\"h-6 p-1 text-muted-foreground\"\n              onClick={() => accept(suggestion)}\n            >\n              <CheckIcon className=\"size-4\" />\n            </Button>\n\n            <Button\n              variant=\"ghost\"\n              className=\"h-6 p-1 text-muted-foreground\"\n              onClick={() => reject(suggestion)}\n            >\n              <XIcon className=\"size-4\" />\n            </Button>\n          </div>\n        )}\n\n        <CommentCreateForm\n          discussionId={suggestion.suggestionId}\n          isSuggesting={suggestion.comments.length === 0}\n        />\n      </div>\n\n      {!isLast && <div className=\"h-px w-full bg-muted\" />}\n    </div>\n  );\n};\n\nexport const useResolveSuggestion = (\n  suggestionNodes: NodeEntry<TElement | TSuggestionText>[],\n  blockPath: Path\n) => {\n  const discussions = useStoreSelect(\n    discussionStore,\n    (state) => state.discussions\n  );\n\n  const { api, editor, getOption, setOption } =\n    useEditorPlugin(suggestionPlugin);\n\n  suggestionNodes.forEach(([node]) => {\n    const id = api.suggestion.nodeId(node);\n    const map = getOption('uniquePathMap');\n\n    if (!id) return;\n\n    const previousPath = map.get(id);\n\n    // If there are no suggestion nodes in the corresponding path in the map, then update it.\n    if (PathApi.isPath(previousPath)) {\n      const nodes = api.suggestion.node({ id, at: previousPath, isText: true });\n      const parentNode = api.node(previousPath);\n      let lineBreakId: string | null = null;\n\n      if (parentNode && ElementApi.isElement(parentNode[0])) {\n        lineBreakId = api.suggestion.nodeId(parentNode[0]) ?? null;\n      }\n\n      if (!nodes && lineBreakId !== id) {\n        return setOption('uniquePathMap', new Map(map).set(id, blockPath));\n      }\n\n      return;\n    }\n    setOption('uniquePathMap', new Map(map).set(id, blockPath));\n  });\n\n  const resolvedSuggestion: ResolvedSuggestion[] = useMemo(() => {\n    const map = getOption('uniquePathMap');\n\n    if (suggestionNodes.length === 0) return [];\n\n    const suggestionIds = new Set(\n      suggestionNodes\n        .flatMap(([node]) => {\n          if (TextApi.isText(node)) {\n            const dataList = api.suggestion.dataList(node);\n            const includeUpdate = dataList.some(\n              (data) => data.type === 'update'\n            );\n\n            if (!includeUpdate) return api.suggestion.nodeId(node);\n\n            return dataList\n              .filter((data) => data.type === 'update')\n              .map((d) => d.id);\n          }\n          if (ElementApi.isElement(node)) {\n            return api.suggestion.nodeId(node);\n          }\n        })\n        .filter(Boolean)\n    );\n\n    const res: ResolvedSuggestion[] = [];\n\n    suggestionIds.forEach((id) => {\n      if (!id) return;\n\n      const path = map.get(id);\n\n      if (!path || !PathApi.isPath(path)) return;\n      if (!PathApi.equals(path, blockPath)) return;\n\n      const entries = [\n        ...editor.api.nodes<TElement | TSuggestionText>({\n          at: [],\n          mode: 'all',\n          match: (n) =>\n            (n[SuggestionPlugin.key] && n[getSuggestionKey(id)]) ||\n            api.suggestion.nodeId(n as TElement) === id,\n        }),\n      ];\n\n      // move line break to the end\n      entries.sort(([, path1], [, path2]) => {\n        return PathApi.isChild(path1, path2) ? -1 : 1;\n      });\n\n      let newText = '';\n      let text = '';\n      let properties: any = {};\n      let newProperties: any = {};\n\n      // overlapping suggestion\n      entries.forEach(([node]) => {\n        if (TextApi.isText(node)) {\n          const dataList = api.suggestion.dataList(node);\n\n          dataList.forEach((data) => {\n            if (data.id !== id) return;\n\n            switch (data.type) {\n              case 'insert': {\n                newText += node.text;\n\n                break;\n              }\n              case 'remove': {\n                text += node.text;\n\n                break;\n              }\n              case 'update': {\n                properties = {\n                  ...properties,\n                  ...data.properties,\n                };\n\n                newProperties = {\n                  ...newProperties,\n                  ...data.newProperties,\n                };\n\n                newText += node.text;\n\n                break;\n              }\n              // No default\n            }\n          });\n        } else {\n          const lineBreakData = api.suggestion.isBlockSuggestion(node)\n            ? node.suggestion\n            : undefined;\n\n          if (lineBreakData?.id !== keyId2SuggestionId(id)) return;\n          if (lineBreakData.type === 'insert') {\n            newText += lineBreakData.isLineBreak\n              ? BLOCK_SUGGESTION\n              : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type](node);\n          } else if (lineBreakData.type === 'remove') {\n            text += lineBreakData.isLineBreak\n              ? BLOCK_SUGGESTION\n              : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type](node);\n          }\n        }\n      });\n\n      if (entries.length === 0) return;\n\n      const nodeData = api.suggestion.suggestionData(entries[0][0]);\n\n      if (!nodeData) return;\n\n      // const comments = data?.discussions.find((d) => d.id === id)?.comments;\n      const comments =\n        discussions.find((s: TDiscussion) => s.id === id)?.comments || [];\n      const createdAt = new Date(nodeData.createdAt);\n\n      const keyId = getSuggestionKey(id);\n\n      if (nodeData.type === 'update') {\n        return res.push({\n          comments,\n          createdAt,\n          keyId,\n          newProperties,\n          newText,\n          properties,\n          suggestionId: keyId2SuggestionId(id),\n          type: 'update',\n          userId: nodeData.userId,\n        });\n      }\n      if (newText.length > 0 && text.length > 0) {\n        return res.push({\n          comments,\n          createdAt,\n          keyId,\n          newText,\n          suggestionId: keyId2SuggestionId(id),\n          text,\n          type: 'replace',\n          userId: nodeData.userId,\n        });\n      }\n      if (newText.length > 0) {\n        return res.push({\n          comments,\n          createdAt,\n          keyId,\n          newText,\n          suggestionId: keyId2SuggestionId(id),\n          type: 'insert',\n          userId: nodeData.userId,\n        });\n      }\n      if (text.length > 0) {\n        return res.push({\n          comments,\n          createdAt,\n          keyId,\n          suggestionId: keyId2SuggestionId(id),\n          text,\n          type: 'remove',\n          userId: nodeData.userId,\n        });\n      }\n    });\n\n    return res;\n  }, [\n    api.suggestion,\n    blockPath,\n    discussions,\n    editor.api,\n    getOption,\n    suggestionNodes,\n  ]);\n\n  return resolvedSuggestion;\n};\n\nexport const isResolvedSuggestion = (\n  suggestion: ResolvedSuggestion | TDiscussion\n): suggestion is ResolvedSuggestion => {\n  return 'suggestionId' in suggestion;\n};\n\nexport function BlockSuggestion({ element }: { element: TSuggestionElement }) {\n  const suggestionData = element.suggestion;\n\n  if (suggestionData?.isLineBreak) return null;\n\n  const isRemove = suggestionData?.type === 'remove';\n\n  return (\n    <div\n      className={cn(\n        'pointer-events-none absolute inset-0 z-1 border-2 border-brand/[0.8] transition-opacity',\n        isRemove && 'border-gray-300'\n      )}\n      contentEditable={false}\n    />\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/plate-ui/block-suggestion.tsx"
    },
    {
      "path": "plate-ui/comment.tsx",
      "content": "'use client';\n\nimport React, { useState } from 'react';\n\nimport type { Value } from '@udecode/plate';\n\nimport { cn } from '@udecode/cn';\nimport { CommentsPlugin } from '@udecode/plate-comments/react';\nimport { Plate, useEditorPlugin, useStoreValue } from '@udecode/plate/react';\nimport {\n  differenceInDays,\n  differenceInHours,\n  differenceInMinutes,\n  format,\n} from 'date-fns';\nimport {\n  CheckIcon,\n  MoreHorizontalIcon,\n  PencilIcon,\n  TrashIcon,\n  XIcon,\n} from 'lucide-react';\n\nimport { Avatar, AvatarFallback, AvatarImage } from './avatar';\nimport {\n  discussionStore,\n  useFakeCurrentUserId,\n  useFakeUserInfo,\n} from './block-discussion';\nimport { Button } from './button';\nimport { useCommentEditor } from './comment-create-form';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from './dropdown-menu';\nimport { Editor, EditorContainer } from './editor';\n\nexport const formatCommentDate = (date: Date) => {\n  const now = new Date();\n  const diffMinutes = differenceInMinutes(now, date);\n  const diffHours = differenceInHours(now, date);\n  const diffDays = differenceInDays(now, date);\n\n  if (diffMinutes < 60) {\n    return `${diffMinutes}m`;\n  }\n  if (diffHours < 24) {\n    return `${diffHours}h`;\n  }\n  if (diffDays < 2) {\n    return `${diffDays}d`;\n  }\n\n  return format(date, 'MM/dd/yyyy');\n};\n\nexport interface TComment {\n  id: string;\n  contentRich: Value;\n  createdAt: Date;\n  discussionId: string;\n  isEdited: boolean;\n  userId: string;\n}\n\nexport function Comment(props: {\n  comment: TComment;\n  discussionLength: number;\n  editingId: string | null;\n  index: number;\n  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;\n  documentContent?: string;\n  showDocumentContent?: boolean;\n  onEditorClick?: () => void;\n}) {\n  const {\n    comment,\n    discussionLength,\n    documentContent,\n    editingId,\n    index,\n    setEditingId,\n    showDocumentContent = false,\n    onEditorClick,\n  } = props;\n  // const { user } = comment;\n\n  const discussions = useStoreValue(discussionStore, 'discussions');\n  const userInfo = useFakeUserInfo(comment.userId);\n  const currentUserId = useFakeCurrentUserId();\n\n  const resolveDiscussion = async (id: string) => {\n    const updatedDiscussions = discussions.map((discussion) => {\n      if (discussion.id === id) {\n        return { ...discussion, isResolved: true };\n      }\n      return discussion;\n    });\n    discussionStore.set('discussions', updatedDiscussions);\n  };\n\n  const removeDiscussion = async (id: string) => {\n    const updatedDiscussions = discussions.filter(\n      (discussion: any) => discussion.id !== id\n    );\n    discussionStore.set('discussions', updatedDiscussions);\n  };\n\n  const updateComment = async (input: {\n    id: string;\n    contentRich: any;\n    discussionId: string;\n    isEdited: boolean;\n  }) => {\n    const updatedDiscussions = discussions.map((discussion) => {\n      if (discussion.id === input.discussionId) {\n        const updatedComments = discussion.comments.map((comment) => {\n          if (comment.id === input.id) {\n            return {\n              ...comment,\n              contentRich: input.contentRich,\n              isEdited: true,\n              updatedAt: new Date(),\n            };\n          }\n          return comment;\n        });\n        return { ...discussion, comments: updatedComments };\n      }\n      return discussion;\n    });\n    discussionStore.set('discussions', updatedDiscussions);\n  };\n\n  const { tf } = useEditorPlugin(CommentsPlugin);\n\n  // Replace to your own backend or refer to potion\n  const isMyComment = currentUserId === comment.userId;\n\n  const initialValue = comment.contentRich;\n\n  const commentEditor = useCommentEditor(\n    {\n      id: comment.id,\n      value: initialValue,\n    },\n    [initialValue]\n  );\n\n  const onCancel = () => {\n    setEditingId(null);\n    commentEditor.tf.replaceNodes(initialValue, {\n      at: [],\n      children: true,\n    });\n  };\n\n  const onSave = () => {\n    void updateComment({\n      id: comment.id,\n      contentRich: commentEditor.children,\n      discussionId: comment.discussionId,\n      isEdited: true,\n    });\n    setEditingId(null);\n  };\n\n  const onResolveComment = () => {\n    void resolveDiscussion(comment.discussionId);\n    tf.comment.unsetMark({ id: comment.discussionId });\n  };\n\n  const isFirst = index === 0;\n  const isLast = index === discussionLength - 1;\n  const isEditing = editingId && editingId === comment.id;\n\n  const [hovering, setHovering] = useState(false);\n  const [dropdownOpen, setDropdownOpen] = useState(false);\n\n  return (\n    <div\n      onMouseEnter={() => setHovering(true)}\n      onMouseLeave={() => setHovering(false)}\n    >\n      <div className=\"relative flex items-center\">\n        <Avatar className=\"size-6\">\n          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />\n          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>\n        </Avatar>\n        <h4 className=\"mx-2 text-sm leading-none font-semibold\">\n          {/* Replace to your own backend or refer to potion */}\n          {userInfo?.name}\n        </h4>\n\n        <div className=\"text-xs leading-none text-muted-foreground/80\">\n          <span className=\"mr-1\">\n            {formatCommentDate(new Date(comment.createdAt))}\n          </span>\n          {comment.isEdited && <span>(edited)</span>}\n        </div>\n\n        {isMyComment && (hovering || dropdownOpen) && (\n          <div className=\"absolute top-0 right-0 flex space-x-1\">\n            {index === 0 && (\n              <Button\n                variant=\"ghost\"\n                className=\"h-6 p-1 text-muted-foreground\"\n                onClick={onResolveComment}\n                type=\"button\"\n              >\n                <CheckIcon className=\"size-4\" />\n              </Button>\n            )}\n\n            <CommentMoreDropdown\n              onCloseAutoFocus={() => {\n                setTimeout(() => {\n                  commentEditor.tf.focus({ edge: 'endEditor' });\n                }, 0);\n              }}\n              onRemoveComment={() => {\n                if (discussionLength === 1) {\n                  tf.comment.unsetMark({ id: comment.discussionId });\n                  void removeDiscussion(comment.discussionId);\n                }\n              }}\n              comment={comment}\n              dropdownOpen={dropdownOpen}\n              setDropdownOpen={setDropdownOpen}\n              setEditingId={setEditingId}\n            />\n          </div>\n        )}\n      </div>\n\n      {isFirst && showDocumentContent && (\n        <div className=\"text-subtle-foreground relative mt-1 flex pl-[32px] text-sm\">\n          {discussionLength > 1 && (\n            <div className=\"absolute top-[5px] left-3 h-full w-0.5 shrink-0 bg-muted\" />\n          )}\n          <div className=\"my-px w-0.5 shrink-0 bg-highlight\" />\n          {documentContent && <div className=\"ml-2\">{documentContent}</div>}\n        </div>\n      )}\n\n      <div className=\"relative my-1 pl-[26px]\">\n        {!isLast && (\n          <div className=\"absolute top-0 left-3 h-full w-0.5 shrink-0 bg-muted\" />\n        )}\n        <Plate readOnly={!isEditing} editor={commentEditor}>\n          <EditorContainer variant=\"comment\">\n            <Editor\n              variant=\"comment\"\n              className=\"w-auto grow\"\n              onClick={() => onEditorClick?.()}\n            />\n\n            {isEditing && (\n              <div className=\"ml-auto flex shrink-0 gap-1\">\n                <Button\n                  size=\"icon\"\n                  variant=\"ghost\"\n                  className=\"size-[28px]\"\n                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {\n                    e.stopPropagation();\n                    void onCancel();\n                  }}\n                >\n                  <div className=\"flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-primary/40\">\n                    <XIcon className=\"size-3 stroke-[3px] text-background\" />\n                  </div>\n                </Button>\n\n                <Button\n                  size=\"icon\"\n                  variant=\"ghost\"\n                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {\n                    e.stopPropagation();\n                    void onSave();\n                  }}\n                >\n                  <div className=\"flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-brand\">\n                    <CheckIcon className=\"size-3 stroke-[3px] text-background\" />\n                  </div>\n                </Button>\n              </div>\n            )}\n          </EditorContainer>\n        </Plate>\n      </div>\n    </div>\n  );\n}\ninterface CommentMoreDropdownProps {\n  comment: TComment;\n  dropdownOpen: boolean;\n  setDropdownOpen: React.Dispatch<React.SetStateAction<boolean>>;\n  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;\n  onCloseAutoFocus?: () => void;\n  onRemoveComment?: () => void;\n}\n\nexport function CommentMoreDropdown(props: CommentMoreDropdownProps) {\n  const {\n    comment,\n    dropdownOpen,\n    setDropdownOpen,\n    setEditingId,\n    onCloseAutoFocus,\n    onRemoveComment,\n  } = props;\n\n  const discussions = useStoreValue(discussionStore, 'discussions');\n\n  const selectedEditCommentRef = React.useRef<boolean>(false);\n\n  const onDeleteComment = React.useCallback(() => {\n    if (!comment.id)\n      return alert('You are operating too quickly, please try again later.');\n\n    // Find and update the discussion\n    const updatedDiscussions = discussions.map((discussion: any) => {\n      if (discussion.id !== comment.discussionId) {\n        return discussion;\n      }\n\n      const commentIndex = discussion.comments.findIndex(\n        (c: any) => c.id === comment.id\n      );\n      if (commentIndex === -1) {\n        return discussion;\n      }\n\n      return {\n        ...discussion,\n        comments: [\n          ...discussion.comments.slice(0, commentIndex),\n          ...discussion.comments.slice(commentIndex + 1),\n        ],\n      };\n    });\n\n    // Save back to session storage\n    discussionStore.set('discussions', updatedDiscussions);\n    onRemoveComment?.();\n  }, [comment.discussionId, comment.id, discussions, onRemoveComment]);\n\n  const onEditComment = React.useCallback(() => {\n    selectedEditCommentRef.current = true;\n\n    if (!comment.id)\n      return alert('You are operating too quickly, please try again later.');\n\n    setEditingId(comment.id);\n  }, [comment.id, setEditingId]);\n\n  return (\n    <DropdownMenu\n      open={dropdownOpen}\n      onOpenChange={setDropdownOpen}\n      modal={false}\n    >\n      <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>\n        <Button variant=\"ghost\" className={cn('h-6 p-1 text-muted-foreground')}>\n          <MoreHorizontalIcon className=\"size-4\" />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent\n        className=\"w-48\"\n        onCloseAutoFocus={(e) => {\n          if (selectedEditCommentRef.current) {\n            onCloseAutoFocus?.();\n            selectedEditCommentRef.current = false;\n          }\n\n          return e.preventDefault();\n        }}\n      >\n        <DropdownMenuGroup>\n          <DropdownMenuItem onClick={onEditComment}>\n            <PencilIcon className=\"size-4\" />\n            Edit comment\n          </DropdownMenuItem>\n          <DropdownMenuItem onClick={onDeleteComment}>\n            <TrashIcon className=\"size-4\" />\n            Delete comment\n          </DropdownMenuItem>\n        </DropdownMenuGroup>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/plate-ui/comment.tsx"
    },
    {
      "path": "plate-ui/comment-create-form.tsx",
      "content": "'use client';\n\nimport React, { useEffect, useMemo } from 'react';\n\nimport { cn, withProps } from '@udecode/cn';\nimport { type Value, nanoid, NodeApi } from '@udecode/plate';\nimport { AIPlugin } from '@udecode/plate-ai/react';\nimport {\n  BasicMarksPlugin,\n  BoldPlugin,\n  ItalicPlugin,\n  StrikethroughPlugin,\n  UnderlinePlugin,\n} from '@udecode/plate-basic-marks/react';\nimport { getCommentKey, getDraftCommentKey } from '@udecode/plate-comments';\nimport { CommentsPlugin, useCommentId } from '@udecode/plate-comments/react';\nimport { DatePlugin } from '@udecode/plate-date/react';\nimport { EmojiInputPlugin } from '@udecode/plate-emoji/react';\nimport { LinkPlugin } from '@udecode/plate-link/react';\nimport { InlineEquationPlugin } from '@udecode/plate-math/react';\nimport {\n  MentionInputPlugin,\n  MentionPlugin,\n} from '@udecode/plate-mention/react';\nimport { Plate, useEditorRef, useStoreSelect } from '@udecode/plate/react';\nimport { type CreatePlateEditorOptions, PlateLeaf } from '@udecode/plate/react';\nimport { ArrowUpIcon } from 'lucide-react';\n\nimport { useCreateEditor } from '@/components/editor/use-create-editor';\nimport {\n  Avatar,\n  AvatarFallback,\n  AvatarImage,\n} from '@/components/plate-ui/avatar';\n\nimport type { TDiscussion } from './block-discussion';\nimport type { TComment } from './comment';\n\nimport { AILeaf } from './ai-leaf';\nimport {\n  discussionStore,\n  useFakeCurrentUserId,\n  useFakeUserInfo,\n} from './block-discussion';\nimport { Button } from './button';\nimport { DateElement } from './date-element';\nimport { Editor, EditorContainer } from './editor';\nimport { EmojiInputElement } from './emoji-input-element';\nimport { InlineEquationElement } from './inline-equation-element';\nimport { LinkElement } from './link-element';\nimport { MentionElement } from './mention-element';\nimport { MentionInputElement } from './mention-input-element';\n\nexport const useCommentEditor = (\n  options: Omit<CreatePlateEditorOptions, 'plugins'> = {},\n  deps: any[] = []\n) => {\n  const commentEditor = useCreateEditor(\n    {\n      id: 'comment',\n      override: {\n        components: {\n          [AIPlugin.key]: AILeaf,\n          [BoldPlugin.key]: withProps(PlateLeaf, { as: 'strong' }),\n          [DatePlugin.key]: DateElement,\n          [EmojiInputPlugin.key]: EmojiInputElement,\n          [InlineEquationPlugin.key]: InlineEquationElement,\n          [ItalicPlugin.key]: withProps(PlateLeaf, { as: 'em' }),\n          [LinkPlugin.key]: LinkElement,\n          [MentionInputPlugin.key]: MentionInputElement,\n          [MentionPlugin.key]: MentionElement,\n          [StrikethroughPlugin.key]: withProps(PlateLeaf, { as: 's' }),\n          [UnderlinePlugin.key]: withProps(PlateLeaf, { as: 'u' }),\n          // [SlashInputPlugin.key]: SlashInputElement,\n        },\n      },\n      plugins: [BasicMarksPlugin],\n      value: [],\n      ...options,\n    },\n    deps\n  );\n\n  return commentEditor;\n};\n\nexport function CommentCreateForm({\n  autoFocus = false,\n  className,\n  discussionId: discussionIdProp,\n  focusOnMount = false,\n  isSuggesting,\n}: {\n  autoFocus?: boolean;\n  className?: string;\n  discussionId?: string;\n  focusOnMount?: boolean;\n  isSuggesting?: boolean;\n}) {\n  const discussions = useStoreSelect(\n    discussionStore,\n    (state) => state.discussions\n  );\n\n  const editor = useEditorRef();\n  const discussionId = useCommentId() ?? discussionIdProp;\n  const [resetKey, setResetKey] = React.useState(0);\n\n  const currentUserId = useFakeCurrentUserId();\n  const userInfo = useFakeUserInfo(currentUserId);\n  const [commentValue, setCommentValue] = React.useState<Value | undefined>();\n  const commentContent = useMemo(\n    () =>\n      commentValue\n        ? NodeApi.string({ children: commentValue as any, type: 'p' })\n        : '',\n    [commentValue]\n  );\n  const commentEditor = useCommentEditor({}, [resetKey]);\n\n  useEffect(() => {\n    if (commentEditor && focusOnMount) {\n      commentEditor.tf.focus();\n    }\n  }, [commentEditor, focusOnMount]);\n\n  const onAddComment = React.useCallback(async () => {\n    setResetKey((prev) => prev + 1);\n\n    if (discussionId) {\n      // Get existing discussion\n      const discussion = discussions.find((d: any) => d.id === discussionId);\n\n      if (!discussion || !commentValue) return;\n\n      // Create reply comment\n      const comment: TComment = {\n        id: nanoid(),\n        contentRich: commentValue,\n        createdAt: new Date(),\n        discussionId,\n        isEdited: false,\n        // mock user id\n        userId: currentUserId,\n      };\n\n      // Add reply to discussion comments\n      const updatedDiscussion = {\n        ...discussion,\n        comments: [...discussion.comments, comment],\n      };\n\n      // Filter out old discussion and add updated one\n      const updatedDiscussions = discussions\n        .filter((d: any) => d.id !== discussionId)\n        .concat(updatedDiscussion);\n\n      discussionStore.set('discussions', updatedDiscussions);\n\n      return;\n    }\n\n    const commentsNodeEntry = editor\n      .getApi(CommentsPlugin)\n      .comment.nodes({ at: [], isDraft: true });\n\n    if (commentsNodeEntry.length === 0) return;\n\n    const documentContent = commentsNodeEntry\n      .map(([node]) => node.text)\n      .join('');\n\n    const _discussionId = nanoid();\n    // Mock creating new discussion\n    const newDiscussion: TDiscussion = {\n      id: _discussionId,\n      comments: [\n        {\n          id: nanoid(),\n          contentRich: commentValue!,\n          createdAt: new Date(),\n          discussionId: _discussionId,\n          isEdited: false,\n          userId: currentUserId,\n        },\n      ],\n      createdAt: new Date(),\n      documentContent,\n      isResolved: false,\n      userId: currentUserId,\n    };\n\n    // Update discussions store\n    discussionStore.set('discussions', [...discussions, newDiscussion]);\n\n    const id = newDiscussion.id;\n\n    commentsNodeEntry.forEach(([_, path]) => {\n      editor.tf.setNodes(\n        {\n          [getCommentKey(id)]: true,\n        },\n        { at: path, split: true }\n      );\n      editor.tf.unsetNodes([getDraftCommentKey()], { at: path });\n    });\n  }, [discussionId, editor, commentValue, currentUserId, discussions]);\n\n  const onAddSuggestion = React.useCallback(async () => {\n    if (!discussionId) return;\n\n    if (!commentValue) return;\n\n    // Mock creating suggestion\n    const suggestion: TDiscussion = {\n      id: discussionId,\n      comments: [\n        {\n          id: nanoid(),\n          contentRich: commentValue!,\n          createdAt: new Date(),\n          discussionId,\n          isEdited: false,\n          userId: 'user1',\n        },\n      ],\n      createdAt: new Date(),\n      isResolved: false,\n      userId: 'user1',\n    };\n\n    // Update discussions store\n    discussionStore.set('discussions', [...discussions, suggestion]);\n  }, [discussionId, commentValue, discussions]);\n\n  return (\n    <div className={cn('flex w-full', className)}>\n      <div className=\"mt-1 mr-1 shrink-0\">\n        {/* Replace to your own backend or refer to potion */}\n        <Avatar className=\"size-6\">\n          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />\n          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>\n        </Avatar>\n      </div>\n\n      <div className=\"relative flex grow gap-2\">\n        <Plate\n          onChange={({ value }) => {\n            setCommentValue(value);\n          }}\n          editor={commentEditor}\n        >\n          <EditorContainer variant=\"comment\">\n            <Editor\n              variant=\"comment\"\n              className=\"min-h-[25px] grow pt-0.5 pr-8\"\n              placeholder=\"Reply...\"\n              autoComplete=\"off\"\n              autoFocus={autoFocus}\n            />\n\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              className=\"absolute right-0 bottom-0 ml-auto shrink-0\"\n              disabled={commentContent.trim().length === 0}\n              onClick={(e) => {\n                e.stopPropagation();\n\n                if (isSuggesting) {\n                  void onAddSuggestion();\n                } else {\n                  void onAddComment();\n                }\n              }}\n            >\n              <div className=\"flex size-6 items-center justify-center rounded-full\">\n                <ArrowUpIcon />\n              </div>\n            </Button>\n          </EditorContainer>\n        </Plate>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/plate-ui/comment-create-form.tsx"
    }
  ],
  "name": "block-discussion",
  "registryDependencies": [
    "suggestion-plugin",
    "button",
    "popover",
    "avatar",
    "dropdown-menu",
    "editor",
    "ai-leaf",
    "avatar",
    "date-element",
    "emoji-input-element",
    "inline-equation-element",
    "link-element",
    "mention-element",
    "mention-input-element"
  ],
  "type": "registry:ui",
  "$schema": "https://platejs.org/schema/registry-item.json",
  "author": "udecode (https://platejs.org)"
}