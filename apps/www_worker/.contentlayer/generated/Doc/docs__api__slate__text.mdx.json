{
  "component": false,
  "description": "API reference for text nodes in Plate.",
  "featured": false,
  "published": true,
  "title": "Text",
  "toc": true,
  "body": {
    "raw": "\nA Text node contains the actual text content of a Plate document along with any formatting properties. They are always leaf nodes in the document tree as they cannot contain any children.\n\n```ts\ntype TText = {\n  text: string\n  [key: string]: unknown\n}\n```\n\n## `TextApi`\n\n### `decorations`\n\n<API name=\"decorations\">\n<APIParameters>\n  <APIItem name=\"node\" type=\"TText\">\n    The text node to get leaves from.\n  </APIItem>\n  <APIItem name=\"decorations\" type=\"DecoratedRange[]\">\n    The array of decorated ranges to apply.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"{ leaf: TText, position?: LeafPosition }[]\">\n  An array of leaves and their positions. The position is undefined if there is a single leaf.\n</APIReturns>\n</API>\n\n### `equals`\n\n<API name=\"equals\">\n<APIParameters>\n  <APIItem name=\"text\" type=\"TText\">\n    The first text node to compare.\n  </APIItem>\n  <APIItem name=\"another\" type=\"TText\">\n    The second text node to compare.\n  </APIItem>\n  <APIItem name=\"options\" type=\"TextEqualsOptions\" optional>\n    Additional comparison options.\n  </APIItem>\n</APIParameters>\n\n<APIOptions type=\"TextEqualsOptions\">\n  <APIItem name=\"loose\" type=\"boolean\" optional>\n    If `true`, the text content is not compared. This is used to check\n    whether sibling text nodes can be merged based only on their\n    formatting properties.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"boolean\">\n  `true` if the text nodes are equal according to the comparison rules.\n</APIReturns>\n</API>\n\n### `isText`\n\n<API name=\"isText\">\n<APIParameters>\n  <APIItem name=\"value\" type=\"any\">\n    The value to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the value is a valid text node.\n</APIReturns>\n</API>\n\n### `isTextList`\n\n<API name=\"isTextList\">\n<APIParameters>\n  <APIItem name=\"value\" type=\"any\">\n    The value to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the value is an array of text nodes.\n</APIReturns>\n</API>\n\n### `isTextProps`\n\n<API name=\"isTextProps\">\n<APIParameters>\n  <APIItem name=\"props\" type=\"any\">\n    The props to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the props match a partial text node structure.\n</APIReturns>\n</API>\n\n### `matches`\n\n<API name=\"matches\">\n<APIParameters>\n  <APIItem name=\"text\" type=\"TText\">\n    The text node to check.\n  </APIItem>\n  <APIItem name=\"props\" type=\"Partial<TText>\">\n    The properties to match against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the text node matches the properties.\n</APIReturns>\n</API>\n\n## Types\n\n### `TText`\n\n`Text` is a type alias for `TText`.\n\n<API name=\"TText\">\n<APIAttributes>\n  <APIItem name=\"text\" type=\"string\">\n    The text content of the node.\n  </APIItem>\n  <APIItem name=\"[key: string]\" type=\"unknown\">\n    Additional formatting properties that can be added to the text node.\n  </APIItem>\n</APIAttributes>\n</API>\n\n### `TextEntry` \n\nText entries represent a Text node and its path.\n\n<API name=\"TextEntry\">\n<APIAttributes>\n  <APIItem name=\"0\" type=\"TText\">\n    The Text node.\n  </APIItem>\n  <APIItem name=\"1\" type=\"Path\">\n    The path to the text node.\n  </APIItem>\n</APIAttributes>\n</API>\n\n### `DecoratedRange`\n\nA range object that includes decoration information. Used to apply formatting or styling to specific ranges of text within a document.\n\n### `TextOf<N>`\n\nA utility type that extracts all possible text node types from a root node type.\n\n<API name=\"TextOf\">\n<APIParameters>\n  <APIItem name=\"N\" type=\"TNode\">\n    The root node type to extract text types from.\n  </APIItem>\n</APIParameters>\n</API>\n\n### `TextIn<V>`\n\nA utility type that extracts all text node types from a `Value` type.\n\n<API name=\"TextIn\">\n<APIParameters>\n  <APIItem name=\"V\" type=\"Value\">\n    The `Value` type to extract text types from.\n  </APIItem>\n</APIParameters>\n</API>\n\n### `MarksOf<N>`\n\nA utility type that extracts all possible mark types from a root node type. Marks are the formatting properties that can be applied to text nodes.\n\n<API name=\"MarksOf\">\n<APIParameters>\n  <APIItem name=\"N\" type=\"TNode\">\n    The root node type to extract mark types from.\n  </APIItem>\n</APIParameters>\n</API>\n\n### `MarksIn<V>`\n\nA utility type that extracts all mark types from a `Value` type. Similar to `MarksOf` but works specifically with editor `Value` types.\n\n<API name=\"MarksIn\">\n<APIParameters>\n  <APIItem name=\"V\" type=\"Value\">\n    The `Value` type to extract mark types from.\n  </APIItem>\n</APIParameters>\n</API>\n\n### `MarkKeysOf<N>`\n\nA utility type that extracts all possible mark property keys from a node type.\n\n<API name=\"MarkKeysOf\">\n<APIParameters>\n  <APIItem name=\"N\" type=\"TNode\">\n    The node type to extract mark keys from.\n  </APIItem>\n</APIParameters>\n</API>",
    "code": "var Component=(()=>{var x=Object.create;var d=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var b=(a,n)=>()=>(n||a((n={exports:{}}).exports,n),n.exports),N=(a,n)=>{for(var i in n)d(a,i,{get:n[i],enumerable:!0})},h=(a,n,i,o)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let t of g(n))!T.call(a,t)&&t!==i&&d(a,t,{get:()=>n[t],enumerable:!(o=f(n,t))||o.enumerable});return a};var A=(a,n,i)=>(i=a!=null?x(k(a)):{},h(n||!a||!a.__esModule?d(i,\"default\",{value:a,enumerable:!0}):i,a)),P=a=>h(d({},\"__esModule\",{value:!0}),a);var m=b((E,p)=>{p.exports=_jsx_runtime});var L={};N(L,{default:()=>y,frontmatter:()=>I});var e=A(m()),I={title:\"Text\",description:\"API reference for text nodes in Plate.\"};function u(a){let n={a:\"a\",code:\"code\",div:\"div\",h2:\"h2\",h3:\"h3\",p:\"p\",pre:\"pre\",span:\"span\",...a.components},{API:i,APIAttributes:o,APIItem:t,APIOptions:s,APIParameters:r,APIReturns:c}=n;return i||l(\"API\",!0),o||l(\"APIAttributes\",!0),t||l(\"APIItem\",!0),s||l(\"APIOptions\",!0),r||l(\"APIParameters\",!0),c||l(\"APIReturns\",!0),(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"A Text node contains the actual text content of a Plate document along with any formatting properties. They are always leaf nodes in the document tree as they cannot contain any children.\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`type TText = {\n  text: string\n  [key: string]: unknown\n}\n`,children:(0,e.jsxs)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:[(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\"type\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\" TText\"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\" =\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" {\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#FFAB70\"},children:\"  text\"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\":\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\" string\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"  [key: string]\"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\":\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\" unknown\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"}\"})})]})})}),`\n`,(0,e.jsxs)(n.h2,{id:\"textapi\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#textapi\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"TextApi\"})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"decorations\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#decorations\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"decorations\"})]}),`\n`,(0,e.jsxs)(i,{name:\"decorations\",children:[(0,e.jsxs)(r,{children:[(0,e.jsx)(t,{name:\"node\",type:\"TText\",children:(0,e.jsx)(n.p,{children:\"The text node to get leaves from.\"})}),(0,e.jsx)(t,{name:\"decorations\",type:\"DecoratedRange[]\",children:(0,e.jsx)(n.p,{children:\"The array of decorated ranges to apply.\"})})]}),(0,e.jsx)(c,{type:\"{ leaf: TText, position?: LeafPosition }[]\",children:(0,e.jsx)(n.p,{children:\"An array of leaves and their positions. The position is undefined if there is a single leaf.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"equals\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#equals\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"equals\"})]}),`\n`,(0,e.jsxs)(i,{name:\"equals\",children:[(0,e.jsxs)(r,{children:[(0,e.jsx)(t,{name:\"text\",type:\"TText\",children:(0,e.jsx)(n.p,{children:\"The first text node to compare.\"})}),(0,e.jsx)(t,{name:\"another\",type:\"TText\",children:(0,e.jsx)(n.p,{children:\"The second text node to compare.\"})}),(0,e.jsx)(t,{name:\"options\",type:\"TextEqualsOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Additional comparison options.\"})})]}),(0,e.jsx)(s,{type:\"TextEqualsOptions\",children:(0,e.jsx)(t,{name:\"loose\",type:\"boolean\",optional:!0,children:(0,e.jsxs)(n.p,{children:[\"If \",(0,e.jsx)(n.code,{children:\"true\"}),`, the text content is not compared. This is used to check\nwhether sibling text nodes can be merged based only on their\nformatting properties.`]})})}),(0,e.jsx)(c,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the text nodes are equal according to the comparison rules.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"istext\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#istext\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isText\"})]}),`\n`,(0,e.jsxs)(i,{name:\"isText\",children:[(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"value\",type:\"any\",children:(0,e.jsx)(n.p,{children:\"The value to check.\"})})}),(0,e.jsx)(c,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the value is a valid text node.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"istextlist\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#istextlist\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isTextList\"})]}),`\n`,(0,e.jsxs)(i,{name:\"isTextList\",children:[(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"value\",type:\"any\",children:(0,e.jsx)(n.p,{children:\"The value to check.\"})})}),(0,e.jsx)(c,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the value is an array of text nodes.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"istextprops\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#istextprops\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isTextProps\"})]}),`\n`,(0,e.jsxs)(i,{name:\"isTextProps\",children:[(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"props\",type:\"any\",children:(0,e.jsx)(n.p,{children:\"The props to check.\"})})}),(0,e.jsx)(c,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the props match a partial text node structure.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"matches\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#matches\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"matches\"})]}),`\n`,(0,e.jsxs)(i,{name:\"matches\",children:[(0,e.jsxs)(r,{children:[(0,e.jsx)(t,{name:\"text\",type:\"TText\",children:(0,e.jsx)(n.p,{children:\"The text node to check.\"})}),(0,e.jsx)(t,{name:\"props\",type:\"Partial<TText>\",children:(0,e.jsx)(n.p,{children:\"The properties to match against.\"})})]}),(0,e.jsx)(c,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the text node matches the properties.\"]})})]}),`\n`,(0,e.jsxs)(n.h2,{id:\"types\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#types\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Types\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"ttext\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#ttext\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"TText\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"Text\"}),\" is a type alias for \",(0,e.jsx)(n.code,{children:\"TText\"}),\".\"]}),`\n`,(0,e.jsx)(i,{name:\"TText\",children:(0,e.jsxs)(o,{children:[(0,e.jsx)(t,{name:\"text\",type:\"string\",children:(0,e.jsx)(n.p,{children:\"The text content of the node.\"})}),(0,e.jsx)(t,{name:\"[key: string]\",type:\"unknown\",children:(0,e.jsx)(n.p,{children:\"Additional formatting properties that can be added to the text node.\"})})]})}),`\n`,(0,e.jsxs)(n.h3,{id:\"textentry\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#textentry\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"TextEntry\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Text entries represent a Text node and its path.\"}),`\n`,(0,e.jsx)(i,{name:\"TextEntry\",children:(0,e.jsxs)(o,{children:[(0,e.jsx)(t,{name:\"0\",type:\"TText\",children:(0,e.jsx)(n.p,{children:\"The Text node.\"})}),(0,e.jsx)(t,{name:\"1\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to the text node.\"})})]})}),`\n`,(0,e.jsxs)(n.h3,{id:\"decoratedrange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#decoratedrange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"DecoratedRange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"A range object that includes decoration information. Used to apply formatting or styling to specific ranges of text within a document.\"}),`\n`,(0,e.jsxs)(n.h3,{id:\"textofn\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#textofn\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"TextOf<N>\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"A utility type that extracts all possible text node types from a root node type.\"}),`\n`,(0,e.jsx)(i,{name:\"TextOf\",children:(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"N\",type:\"TNode\",children:(0,e.jsx)(n.p,{children:\"The root node type to extract text types from.\"})})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"textinv\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#textinv\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"TextIn<V>\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"A utility type that extracts all text node types from a \",(0,e.jsx)(n.code,{children:\"Value\"}),\" type.\"]}),`\n`,(0,e.jsx)(i,{name:\"TextIn\",children:(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"V\",type:\"Value\",children:(0,e.jsxs)(n.p,{children:[\"The \",(0,e.jsx)(n.code,{children:\"Value\"}),\" type to extract text types from.\"]})})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"marksofn\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#marksofn\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"MarksOf<N>\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"A utility type that extracts all possible mark types from a root node type. Marks are the formatting properties that can be applied to text nodes.\"}),`\n`,(0,e.jsx)(i,{name:\"MarksOf\",children:(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"N\",type:\"TNode\",children:(0,e.jsx)(n.p,{children:\"The root node type to extract mark types from.\"})})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"marksinv\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#marksinv\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"MarksIn<V>\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"A utility type that extracts all mark types from a \",(0,e.jsx)(n.code,{children:\"Value\"}),\" type. Similar to \",(0,e.jsx)(n.code,{children:\"MarksOf\"}),\" but works specifically with editor \",(0,e.jsx)(n.code,{children:\"Value\"}),\" types.\"]}),`\n`,(0,e.jsx)(i,{name:\"MarksIn\",children:(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"V\",type:\"Value\",children:(0,e.jsxs)(n.p,{children:[\"The \",(0,e.jsx)(n.code,{children:\"Value\"}),\" type to extract mark types from.\"]})})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"markkeysofn\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#markkeysofn\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"MarkKeysOf<N>\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"A utility type that extracts all possible mark property keys from a node type.\"}),`\n`,(0,e.jsx)(i,{name:\"MarkKeysOf\",children:(0,e.jsx)(r,{children:(0,e.jsx)(t,{name:\"N\",type:\"TNode\",children:(0,e.jsx)(n.p,{children:\"The node type to extract mark keys from.\"})})})})]})}function y(a={}){let{wrapper:n}=a.components||{};return n?(0,e.jsx)(n,{...a,children:(0,e.jsx)(u,{...a})}):u(a)}function l(a,n){throw new Error(\"Expected \"+(n?\"component\":\"object\")+\" `\"+a+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return P(L);})();\n;return Component;"
  },
  "_id": "docs/api/slate/text.mdx",
  "_raw": {
    "sourceFilePath": "docs/api/slate/text.mdx",
    "sourceFileName": "text.mdx",
    "sourceFileDir": "docs/api/slate",
    "contentType": "mdx",
    "flattenedPath": "docs/api/slate/text"
  },
  "type": "Doc",
  "slug": "/docs/docs/api/slate/text",
  "slugAsParams": "docs/api/slate/text"
}