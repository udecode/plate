{
  "component": false,
  "description": "API reference for paths in Plate.",
  "featured": false,
  "published": true,
  "title": "Path",
  "toc": true,
  "body": {
    "raw": "\nA Path is a list of indexes that describe a node's exact position in a Plate node tree. Although they are usually relative to the root `Editor` object, they can be relative to any `Node` object.\n\n```ts\ntype Path = number[];\n```\n\n## `PathApi`\n\n### `operationCanTransformPath`\n\nCheck if an operation can affect paths (used as an optimization for dirty-path updates during normalization).\n\n<API name=\"operationCanTransformPath\">\n<APIParameters>\n  <APIItem name=\"operation\" type=\"Operation<N>\">\n    The operation to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the operation is an insert, merge, move, remove, or split operation.\n</APIReturns>\n</API>\n\n### `transform`\n\nTransform a path by an operation.\n\n<API name=\"transform\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to transform.\n  </APIItem>\n  <APIItem name=\"operation\" type=\"Operation\">\n    The operation to apply.\n  </APIItem>\n  <APIItem name=\"options\" type=\"PathTransformOptions\" optional>\n    Options for transforming a path.\n  </APIItem>\n</APIParameters>\n\n<APIOptions type=\"PathTransformOptions\">\n  <APIItem name=\"affinity\" type=\"TextDirection | null\" optional>\n    The affinity of the transform.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Path | null\">\n  The transformed path, or `null` if the path was deleted.\n</APIReturns>\n</API>\n\n### `ancestors`\n\nGet a list of ancestor paths for a given path.\n\n<API name=\"ancestors\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to get ancestors for.\n  </APIItem>\n  <APIItem name=\"options\" type=\"PathAncestorsOptions\" optional>\n    Options for ancestor retrieval.\n  </APIItem>\n</APIParameters>\n\n<APIOptions type=\"PathAncestorsOptions\">\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    If true, returns paths in reverse (deepest to shallowest).\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Path[]\">\n  An array of paths sorted from shallowest to deepest ancestor (unless reversed).\n</APIReturns>\n</API>\n\n### `child`\n\nGet a path to a child at the given index.\n\n<API name=\"child\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The parent path.\n  </APIItem>\n  <APIItem name=\"index\" type=\"number\">\n    The child index.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path\">\n  The path to the child node.\n</APIReturns>\n</API>\n\n### `common`\n\nGet the common ancestor path of two paths.\n\n<API name=\"common\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The first path.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The second path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path\">\n  The common ancestor path.\n</APIReturns>\n</API>\n\n### `compare`\n\nCompare a path to another, returning an integer indicating whether the path was before, at, or after the other.\n\n<API name=\"compare\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The first path to compare.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The second path to compare.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"-1 | 0 | 1\">\n  `-1` if before, `0` if at the same location, `1` if after.\n</APIReturns>\n</API>\n\n### `endsAfter`\n\nCheck if a path ends after one of the indexes in another.\n\n<API name=\"endsAfter\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The path to compare against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` ends after `another`.\n</APIReturns>\n</API>\n\n### `endsAt`\n\nCheck if a path ends at one of the indexes in another.\n\n<API name=\"endsAt\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The path to compare against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` ends at the same index as `another`.\n</APIReturns>\n</API>\n\n### `endsBefore`\n\nCheck if a path ends before one of the indexes in another.\n\n<API name=\"endsBefore\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The path to compare against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` ends before `another`.\n</APIReturns>\n</API>\n\n### `equals`\n\nCheck if a path is exactly equal to another.\n\n<API name=\"equals\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The first path.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The second path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the paths are exactly equal.\n</APIReturns>\n</API>\n\n### `firstChild`\n\nGet a path to the first child of a path.\n\n<API name=\"firstChild\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The parent path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path\">\n  The path to the first child node.\n</APIReturns>\n</API>\n\n### `hasPrevious`\n\nCheck if the path of a previous sibling node exists.\n\n<API name=\"hasPrevious\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if a previous sibling exists.\n</APIReturns>\n</API>\n\n### `isAfter`\n\nCheck if a path is after another.\n\n<API name=\"isAfter\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The path to compare against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the first path is after the second.\n</APIReturns>\n</API>\n\n### `isAncestor`\n\nCheck if a path is an ancestor of another.\n\n<API name=\"isAncestor\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The potential ancestor path.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The potential descendant path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` is an ancestor of `another`.\n</APIReturns>\n</API>\n\n### `isBefore`\n\nCheck if a path is before another.\n\n<API name=\"isBefore\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The path to compare against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the first path is before the second.\n</APIReturns>\n</API>\n\n### `isChild`\n\nCheck if a path is a child of another.\n\n<API name=\"isChild\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The potential child path.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The potential parent path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` is a child of `another`.\n</APIReturns>\n</API>\n\n### `isCommon`\n\nCheck if a path is equal to or an ancestor of another.\n\n<API name=\"isCommon\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The path to compare against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` is equal to or an ancestor of `another`.\n</APIReturns>\n</API>\n\n### `isDescendant`\n\nCheck if a path is a descendant of another.\n\n<API name=\"isDescendant\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The potential descendant path.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The potential ancestor path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` is a descendant of `another`.\n</APIReturns>\n</API>\n\n### `isParent`\n\nCheck if a path is the parent of another.\n\n<API name=\"isParent\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The potential parent path.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The potential child path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if `path` is the parent of `another`.\n</APIReturns>\n</API>\n\n### `isPath`\n\nCheck if a value implements the `Path` interface.\n\n<API name=\"isPath\">\n<APIParameters>\n  <APIItem name=\"value\" type=\"any\">\n    The value to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the value is a path.\n</APIReturns>\n</API>\n\n### `isSibling`\n\nCheck if a path is a sibling of another.\n\n<API name=\"isSibling\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n  <APIItem name=\"another\" type=\"Path\">\n    The path to compare against.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  `true` if the paths share the same parent.\n</APIReturns>\n</API>\n\n### `lastIndex`\n\nGet the last index of a path.\n\n<API name=\"lastIndex\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"number\">\n  The last index, or -1 if the path is empty.\n</APIReturns>\n</API>\n\n### `levels`\n\nGet a list of paths at every level down to a path.\n\n<API name=\"levels\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to get levels for.\n  </APIItem>\n  <APIItem name=\"options\" type=\"PathLevelsOptions\" optional>\n    Options for levels retrieval.\n  </APIItem>\n</APIParameters>\n\n<APIOptions type=\"PathLevelsOptions\">\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    If true, returns paths in reverse (deepest to shallowest).\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Path[]\">\n  An array of paths including the path itself and all its ancestors.\n</APIReturns>\n</API>\n\n### `next`\n\nGet the path to the next sibling node.\n\n<API name=\"next\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The current path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path\">\n  The path to the next sibling.\n</APIReturns>\n</API>\n\n### `parent`\n\nGet the path to the parent node.\n\n<API name=\"parent\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The current path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path\">\n  The path to the parent node.\n</APIReturns>\n</API>\n\n### `previous`\n\nGet the path to the previous sibling node.\n\n<API name=\"previous\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The current path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path | undefined\">\n  The path to the previous sibling, or `undefined` if there is none.\n</APIReturns>\n</API>\n\n### `relative`\n\nGet a path relative to an ancestor.\n\n<API name=\"relative\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to make relative.\n  </APIItem>\n  <APIItem name=\"ancestor\" type=\"Path\">\n    The ancestor path.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path\">\n  The relative path.\n</APIReturns>\n</API>\n\n## Types\n\n### `Path`\n\nAn array of numbers representing the indexes to traverse to reach a specific node in the document tree.",
    "code": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var P=(r,n)=>()=>(n||r((n={exports:{}}).exports,n),n.exports),N=(r,n)=>{for(var i in n)l(r,i,{get:n[i],enumerable:!0})},o=(r,n,i,a)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let c of b(n))!k.call(r,c)&&c!==i&&l(r,c,{get:()=>n[c],enumerable:!(a=y(n,c))||a.enumerable});return r};var T=(r,n,i)=>(i=r!=null?f(g(r)):{},o(n||!r||!r.__esModule?l(i,\"default\",{value:r,enumerable:!0}):i,r)),v=r=>o(l({},\"__esModule\",{value:!0}),r);var p=P((C,s)=>{s.exports=_jsx_runtime});var L={};N(L,{default:()=>u,frontmatter:()=>x});var e=T(p()),x={title:\"Path\",description:\"API reference for paths in Plate.\"};function m(r){let n={a:\"a\",code:\"code\",div:\"div\",h2:\"h2\",h3:\"h3\",p:\"p\",pre:\"pre\",span:\"span\",...r.components},{API:i,APIItem:a,APIOptions:c,APIParameters:h,APIReturns:t}=n;return i||d(\"API\",!0),a||d(\"APIItem\",!0),c||d(\"APIOptions\",!0),h||d(\"APIParameters\",!0),t||d(\"APIReturns\",!0),(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"A Path is a list of indexes that describe a node's exact position in a Plate node tree. Although they are usually relative to the root \",(0,e.jsx)(n.code,{children:\"Editor\"}),\" object, they can be relative to any \",(0,e.jsx)(n.code,{children:\"Node\"}),\" object.\"]}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`type Path = number[];\n`,children:(0,e.jsx)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\"type\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\" Path\"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\" =\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\" number\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"[];\"})]})})})}),`\n`,(0,e.jsxs)(n.h2,{id:\"pathapi\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#pathapi\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"PathApi\"})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"operationcantransformpath\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#operationcantransformpath\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"operationCanTransformPath\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if an operation can affect paths (used as an optimization for dirty-path updates during normalization).\"}),`\n`,(0,e.jsxs)(i,{name:\"operationCanTransformPath\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"operation\",type:\"Operation<N>\",children:(0,e.jsx)(n.p,{children:\"The operation to check.\"})})}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the operation is an insert, merge, move, remove, or split operation.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"transform\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#transform\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"transform\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Transform a path by an operation.\"}),`\n`,(0,e.jsxs)(i,{name:\"transform\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to transform.\"})}),(0,e.jsx)(a,{name:\"operation\",type:\"Operation\",children:(0,e.jsx)(n.p,{children:\"The operation to apply.\"})}),(0,e.jsx)(a,{name:\"options\",type:\"PathTransformOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for transforming a path.\"})})]}),(0,e.jsx)(c,{type:\"PathTransformOptions\",children:(0,e.jsx)(a,{name:\"affinity\",type:\"TextDirection | null\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The affinity of the transform.\"})})}),(0,e.jsx)(t,{type:\"Path | null\",children:(0,e.jsxs)(n.p,{children:[\"The transformed path, or \",(0,e.jsx)(n.code,{children:\"null\"}),\" if the path was deleted.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"ancestors\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#ancestors\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"ancestors\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get a list of ancestor paths for a given path.\"}),`\n`,(0,e.jsxs)(i,{name:\"ancestors\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to get ancestors for.\"})}),(0,e.jsx)(a,{name:\"options\",type:\"PathAncestorsOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for ancestor retrieval.\"})})]}),(0,e.jsx)(c,{type:\"PathAncestorsOptions\",children:(0,e.jsx)(a,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"If true, returns paths in reverse (deepest to shallowest).\"})})}),(0,e.jsx)(t,{type:\"Path[]\",children:(0,e.jsx)(n.p,{children:\"An array of paths sorted from shallowest to deepest ancestor (unless reversed).\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"child\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#child\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"child\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get a path to a child at the given index.\"}),`\n`,(0,e.jsxs)(i,{name:\"child\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The parent path.\"})}),(0,e.jsx)(a,{name:\"index\",type:\"number\",children:(0,e.jsx)(n.p,{children:\"The child index.\"})})]}),(0,e.jsx)(t,{type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to the child node.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"common\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#common\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"common\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the common ancestor path of two paths.\"}),`\n`,(0,e.jsxs)(i,{name:\"common\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The first path.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The second path.\"})})]}),(0,e.jsx)(t,{type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The common ancestor path.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"compare\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#compare\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"compare\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Compare a path to another, returning an integer indicating whether the path was before, at, or after the other.\"}),`\n`,(0,e.jsxs)(i,{name:\"compare\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The first path to compare.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The second path to compare.\"})})]}),(0,e.jsx)(t,{type:\"-1 | 0 | 1\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"-1\"}),\" if before, \",(0,e.jsx)(n.code,{children:\"0\"}),\" if at the same location, \",(0,e.jsx)(n.code,{children:\"1\"}),\" if after.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"endsafter\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#endsafter\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"endsAfter\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path ends after one of the indexes in another.\"}),`\n`,(0,e.jsxs)(i,{name:\"endsAfter\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to compare against.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" ends after \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"endsat\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#endsat\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"endsAt\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path ends at one of the indexes in another.\"}),`\n`,(0,e.jsxs)(i,{name:\"endsAt\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to compare against.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" ends at the same index as \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"endsbefore\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#endsbefore\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"endsBefore\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path ends before one of the indexes in another.\"}),`\n`,(0,e.jsxs)(i,{name:\"endsBefore\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to compare against.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" ends before \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"equals\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#equals\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"equals\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is exactly equal to another.\"}),`\n`,(0,e.jsxs)(i,{name:\"equals\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The first path.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The second path.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the paths are exactly equal.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"firstchild\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#firstchild\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"firstChild\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get a path to the first child of a path.\"}),`\n`,(0,e.jsxs)(i,{name:\"firstChild\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The parent path.\"})})}),(0,e.jsx)(t,{type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to the first child node.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hasprevious\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hasprevious\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasPrevious\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the path of a previous sibling node exists.\"}),`\n`,(0,e.jsxs)(i,{name:\"hasPrevious\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})})}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if a previous sibling exists.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isafter\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isafter\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isAfter\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is after another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isAfter\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to compare against.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the first path is after the second.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isancestor\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isancestor\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isAncestor\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is an ancestor of another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isAncestor\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential ancestor path.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential descendant path.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" is an ancestor of \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isbefore\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isbefore\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isBefore\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is before another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isBefore\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to compare against.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the first path is before the second.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"ischild\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#ischild\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isChild\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is a child of another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isChild\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential child path.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential parent path.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" is a child of \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"iscommon\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#iscommon\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isCommon\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is equal to or an ancestor of another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isCommon\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to compare against.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" is equal to or an ancestor of \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isdescendant\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isdescendant\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isDescendant\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is a descendant of another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isDescendant\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential descendant path.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential ancestor path.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" is a descendant of \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isparent\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isparent\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isParent\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is the parent of another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isParent\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential parent path.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The potential child path.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if \",(0,e.jsx)(n.code,{children:\"path\"}),\" is the parent of \",(0,e.jsx)(n.code,{children:\"another\"}),\".\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"ispath\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#ispath\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isPath\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Check if a value implements the \",(0,e.jsx)(n.code,{children:\"Path\"}),\" interface.\"]}),`\n`,(0,e.jsxs)(i,{name:\"isPath\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"value\",type:\"any\",children:(0,e.jsx)(n.p,{children:\"The value to check.\"})})}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the value is a path.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"issibling\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#issibling\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isSibling\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is a sibling of another.\"}),`\n`,(0,e.jsxs)(i,{name:\"isSibling\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})}),(0,e.jsx)(a,{name:\"another\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to compare against.\"})})]}),(0,e.jsx)(t,{type:\"boolean\",children:(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"true\"}),\" if the paths share the same parent.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"lastindex\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#lastindex\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"lastIndex\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the last index of a path.\"}),`\n`,(0,e.jsxs)(i,{name:\"lastIndex\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})})}),(0,e.jsx)(t,{type:\"number\",children:(0,e.jsx)(n.p,{children:\"The last index, or -1 if the path is empty.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"levels\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#levels\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"levels\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get a list of paths at every level down to a path.\"}),`\n`,(0,e.jsxs)(i,{name:\"levels\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to get levels for.\"})}),(0,e.jsx)(a,{name:\"options\",type:\"PathLevelsOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for levels retrieval.\"})})]}),(0,e.jsx)(c,{type:\"PathLevelsOptions\",children:(0,e.jsx)(a,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"If true, returns paths in reverse (deepest to shallowest).\"})})}),(0,e.jsx)(t,{type:\"Path[]\",children:(0,e.jsx)(n.p,{children:\"An array of paths including the path itself and all its ancestors.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"next\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#next\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"next\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the path to the next sibling node.\"}),`\n`,(0,e.jsxs)(i,{name:\"next\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The current path.\"})})}),(0,e.jsx)(t,{type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to the next sibling.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"parent\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#parent\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"parent\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the path to the parent node.\"}),`\n`,(0,e.jsxs)(i,{name:\"parent\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The current path.\"})})}),(0,e.jsx)(t,{type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to the parent node.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"previous\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#previous\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"previous\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the path to the previous sibling node.\"}),`\n`,(0,e.jsxs)(i,{name:\"previous\",children:[(0,e.jsx)(h,{children:(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The current path.\"})})}),(0,e.jsx)(t,{type:\"Path | undefined\",children:(0,e.jsxs)(n.p,{children:[\"The path to the previous sibling, or \",(0,e.jsx)(n.code,{children:\"undefined\"}),\" if there is none.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"relative\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#relative\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"relative\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get a path relative to an ancestor.\"}),`\n`,(0,e.jsxs)(i,{name:\"relative\",children:[(0,e.jsxs)(h,{children:[(0,e.jsx)(a,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to make relative.\"})}),(0,e.jsx)(a,{name:\"ancestor\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The ancestor path.\"})})]}),(0,e.jsx)(t,{type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The relative path.\"})})]}),`\n`,(0,e.jsxs)(n.h2,{id:\"types\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#types\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Types\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"path\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#path\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"Path\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"An array of numbers representing the indexes to traverse to reach a specific node in the document tree.\"})]})}function u(r={}){let{wrapper:n}=r.components||{};return n?(0,e.jsx)(n,{...r,children:(0,e.jsx)(m,{...r})}):m(r)}function d(r,n){throw new Error(\"Expected \"+(n?\"component\":\"object\")+\" `\"+r+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return v(L);})();\n;return Component;"
  },
  "_id": "docs/api/slate/path.mdx",
  "_raw": {
    "sourceFilePath": "docs/api/slate/path.mdx",
    "sourceFileName": "path.mdx",
    "sourceFileDir": "docs/api/slate",
    "contentType": "mdx",
    "flattenedPath": "docs/api/slate/path"
  },
  "type": "Doc",
  "slug": "/docs/docs/api/slate/path",
  "slugAsParams": "docs/api/slate/path"
}