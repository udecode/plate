{
  "component": false,
  "description": "API reference for the Editor API.",
  "featured": false,
  "published": true,
  "title": "Editor API",
  "toc": true,
  "body": {
    "raw": "\nThe Editor API provides a set of helper functions for querying and manipulating the editor state.\n\n## Common Options\n\n### `At`\n\nA location reference in the editor. Can be either a Location or a Node.\n\n```ts\ntype At = TLocation | TNode\n```\n\nWhen a Node is passed, its path will be found using [`editor.api.findPath()`](/docs/api/slate/editor-api#findpath). This allows you to reference a location by either:\n- A [Location](/docs/api/slate/location) ([Path](/docs/api/slate/path), [Point](/docs/api/slate/point), or [Range](/docs/api/slate/range))\n- A [Node](/docs/api/slate/node)\n\nExample:\n```ts\n// Using a location\neditor.api.nodes({ at: [0, 0] }) // Path location\neditor.api.nodes({ at: { path: [0], offset: 0 } }) // Point location \neditor.api.nodes({ at: { anchor: point1, focus: point2 } }) // Range location\n\n// Using a node reference\nconst node = editor.children[0]\neditor.api.nodes({ at: node }) // Will find node's path internally\n```\n\n### Match\n\nA predicate for matching nodes. The predicate can be either:\n- A function that takes a `node` and its `path` and returns a `boolean`\n- An object where each key-value pair must match the node's properties\n  - Values can be single values or arrays of values to match against\n\nExample:\n```ts\n// Function predicate\neditor.api.nodes({\n  match: (node) => node.type === 'p'\n})\n\n// Object predicate\neditor.api.nodes({\n  match: { type: 'p' }\n})\n\n// Object predicate with multiple possible values\neditor.api.nodes({\n  match: { type: ['p', 'h1'] }\n})\n```\n\n### `QueryMode`\n\nMode for querying nodes in a hierarchy.\n\n<API name=\"QueryMode\">\n<APIOptions type=\"QueryMode\">\n  <APIItem name=\"mode\" type=\"'all' | 'highest' | 'lowest'\" optional>\n    - `'all'` (default): Return all matching nodes\n    - `'highest'`: In a hierarchy of nodes, only return the highest-level matching nodes\n    - `'lowest'`: In a hierarchy of nodes, only return the lowest-level matching nodes\n\n    Example:\n    ```ts\n    // Given this structure:\n    // - blockquote (matches)\n    //   - paragraph (matches)\n    //     - text\n    \n    // mode: 'all' returns both blockquote and paragraph\n    editor.api.nodes({ match: { type: ['blockquote', 'paragraph'] }, mode: 'all' })\n    \n    // mode: 'highest' returns only blockquote\n    editor.api.nodes({ match: { type: ['blockquote', 'paragraph'] }, mode: 'highest' })\n    \n    // mode: 'lowest' returns only paragraph\n    editor.api.nodes({ match: { type: ['blockquote', 'paragraph'] }, mode: 'lowest' })\n    ```\n  </APIItem>\n</APIOptions>\n</API>\n\n### `QueryOptions`\n\nCommon options for querying nodes in the editor.\n\n<API name=\"QueryOptions\">\n<APIOptions type=\"QueryOptions<V>\">\n  <APIItem name=\"at\" type=\"At\" optional>\n    Where to start querying from. Defaults to current editor selection.\n  </APIItem>\n  <APIItem name=\"block\" type=\"boolean\" optional>\n    Match block nodes. When true, only matches block elements.\n  </APIItem>\n  <APIItem name=\"empty\" type=\"boolean\" optional>\n    Match empty/non-empty nodes.\n    - When true, matches only empty nodes\n    - When false, matches only non-empty nodes\n  </APIItem>\n  <APIItem name=\"id\" type=\"boolean | string\" optional>\n    Match the node by id.\n    - When true, matches all nodes with an id\n    - When string, matches nodes with that specific id\n  </APIItem>\n  <APIItem name=\"match\" type=\"Predicate<NodeIn<V>>\" optional>\n    Custom function or object to match nodes.\n    - Function: `(node, path) => boolean`\n    - Object: Key-value pairs that should match the node\n  </APIItem>\n  <APIItem name=\"text\" type=\"boolean\" optional>\n    Match text nodes. When true, matches only text nodes.\n  </APIItem>\n</APIOptions>\n</API>\n\n## `editor.api`\n\n### `above`\n\nGet the matching ancestor above a location in the document.\n\n<API name=\"above\">\n<APIOptions type=\"EditorAboveOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode options.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<N> | undefined\">\n  A tuple containing the matching ancestor node and its path, or `undefined` if no match is found.\n</APIReturns>\n</API>\n\n### `block`\n\nGet the block at a location or find the first block that matches options.  \nBlocks are typically top-level nodes, so this is a common way to retrieve the ancestor block.\n\n```ts\neditor.api.block() // Get block above selection\neditor.api.block({ above: true }) // Get block above selection\neditor.api.block({ at: [0, 0] }) // Get block at [0, 0]\neditor.api.block({ at: [0, 0], above: true }) // Get block at [0]\neditor.api.block({ highest: true }) // Get highest block at selection\n```\n\n<API name=\"block\">\n<APIOptions type=\"EditorBlockOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options for matching blocks.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At | Span\" optional>\n    The location to query at. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"ignoreNonSelectable\" type=\"boolean\" optional>\n    Whether to ignore non-selectable nodes during traversal.\n  </APIItem>\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    Whether to traverse in reverse order.\n  </APIItem>\n  <APIItem name=\"universal\" type=\"boolean\" optional>\n    Whether to ensure the operation works universally across all nodes.\n  </APIItem>\n  <APIItem name=\"above\" type=\"boolean\" optional>\n    If true, get the block above the location. Ignored if `at` is not a block path.\n  </APIItem>\n  <APIItem name=\"highest\" type=\"boolean\" optional>\n    If true, get the highest block at the location (root-level block).\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode for matching blocks.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<N> | undefined\">\n  The matching block node entry or `undefined` if no match is found.\n</APIReturns>\n</API>\n\n### `blocks`\n\nReturns all matching blocks.\n\n<API name=\"blocks\">\n<APIOptions type=\"EditorNodesOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options for matching blocks.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At | Span\" optional>\n    The location to query at. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"ignoreNonSelectable\" type=\"boolean\" optional>\n    Whether to ignore non-selectable nodes during traversal.\n  </APIItem>\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    Whether to traverse in reverse order.\n  </APIItem>\n  <APIItem name=\"universal\" type=\"boolean\" optional>\n    Whether to ensure the operation works universally across all nodes.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode for matching blocks.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<ElementIn<V>>[]\">\n  An array of matching block node entries.\n</APIReturns>\n</API>\n\n### `edgeBlocks`\n\nReturns the edge blocks above a location (default: selection).  \nUseful for retrieving the start and end block of a range.\n\n<API name=\"edgeBlocks\">\n<APIOptions type=\"EditorNodesOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options for matching blocks.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At | Span\" optional>\n    The location to get edge blocks from. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"ignoreNonSelectable\" type=\"boolean\" optional>\n    Whether to ignore non-selectable nodes during traversal.\n  </APIItem>\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    Whether to traverse in reverse order.\n  </APIItem>\n  <APIItem name=\"universal\" type=\"boolean\" optional>\n    Whether to ensure the operation works universally across all nodes.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode for matching blocks.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"[NodeEntry<N1>, NodeEntry<N2>] | null\">\n  A tuple of `[startBlock, endBlock]` above the location, or `null` if not found.\n</APIReturns>\n</API>\n\n### `first`\n\nGet the first node at a location.\n\n<API name=\"first\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\">\n    The location to get the first node from.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"NodeEntry<DescendantIn<V>> | undefined\">\n  A tuple containing the first node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n### `fragment`\n\nGet the fragment at a location or selection.\n\n<API name=\"fragment\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At | null\" optional>\n    The location to extract the fragment from. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorFragmentOptions\" optional>\n    Options for extracting and processing the fragment.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"ElementOrTextIn<V>[] | undefined\">\n  The fragment at the location.\n</APIReturns>\n</API>\n\n### `getFragment`\n\nReturns the fragment at the current selection. Used when cutting or copying, as an example, to get the fragment at the current selection.\n\n<API name=\"getFragment\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to get the fragment from. Defaults to current selection.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"ElementOrTextIn<V>[]\">\n  The fragment at the current selection.\n</APIReturns>\n</API>\n\n### `hasBlocks`\n\nCheck if a node has block children.\n\n<API name=\"hasBlocks\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"ElementIn<V>\">\n    The element to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element has block children, false otherwise.\n</APIReturns>\n</API>\n\n### `hasInlines`\n\nCheck if a node has inline and text children.\n\n<API name=\"hasInlines\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"ElementIn<V>\">\n    The element to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element has inline and text children, false otherwise.\n</APIReturns>\n</API>\n\n### `hasMark`\n\nCheck if mark is active at selection.\n\n<API name=\"hasMark\">\n<APIParameters>\n  <APIItem name=\"key\" type=\"keyof MarksIn<V>\">\n    The mark key to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the mark is active at the current selection, false otherwise.\n</APIReturns>\n</API>\n\n### `hasPath`\n\nCheck if a path exists in the editor.\n\n<API name=\"hasPath\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the path exists, false otherwise.\n</APIReturns>\n</API>\n\n### `hasTexts`\n\nCheck if a node has text children.\n\n<API name=\"hasTexts\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"ElementIn<V>\">\n    The element to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element has text children, false otherwise.\n</APIReturns>\n</API>\n\n### `isAt`\n\nCheck if a location (point/range) is at a specific position.\n\n```ts\n// For ranges:\neditor.api.isAt({ text: true }) // Check if range is in a single text node\neditor.api.isAt({ block: true }) // Check if range is in a single block\neditor.api.isAt({ blocks: true }) // Check if range is across multiple blocks\neditor.api.isAt({ start: true }) // Check if range starts at block start\neditor.api.isAt({ end: true }) // Check if range ends at block end\n\n// For points:\neditor.api.isAt({ word: true }) // Check relative to word boundaries\neditor.api.isAt({ start: true }) // Check if at start\neditor.api.isAt({ end: true }) // Check if at end\n```\n\n<API name=\"isAt\">\n<APIOptions type=\"object\">\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to check. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"text\" type=\"boolean\" optional>\n    Check if range is in a single text node.\n  </APIItem>\n  <APIItem name=\"block\" type=\"boolean\" optional>\n    Check if range is in a single block.\n  </APIItem>\n  <APIItem name=\"blocks\" type=\"boolean\" optional>\n    Check if range is across multiple blocks.\n  </APIItem>\n  <APIItem name=\"start\" type=\"boolean\" optional>\n    Check if at start position.\n  </APIItem>\n  <APIItem name=\"end\" type=\"boolean\" optional>\n    Check if at end position.\n  </APIItem>\n  <APIItem name=\"word\" type=\"boolean\" optional>\n    Check relative to word boundaries.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"boolean\">\n  True if the location matches all specified position criteria, false otherwise.\n</APIReturns>\n</API>\n\n### `isCollapsed`\n\nCheck if the selection is collapsed (start and end points are the same).\n\n<API name=\"isCollapsed\">\n<APIReturns type=\"boolean\">\n  True if the selection is collapsed, false otherwise.\n</APIReturns>\n</API>\n\n### `isEdge`\n\nCheck if a point is an edge of a location.\n\n<API name=\"isEdge\">\n<APIParameters>\n  <APIItem name=\"point\" type=\"Point\">\n    The point to check.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to check against. Defaults to current selection.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the point is an edge of the location, false otherwise.\n</APIReturns>\n</API>\n\n\n### `isEditorEnd`\n\nCheck if selection is at editor end.\n\n<API name=\"isEditorEnd\">\n<APIReturns type=\"boolean\">\n  True if the selection is at the editor end, false otherwise.\n</APIReturns>\n</API>\n\n### `isEmpty`\n\nCheck if an element is empty, accounting for void nodes.\n\n```ts\neditor.api.isEmpty() // Check if editor is empty\neditor.api.isEmpty(at) // Check if nodes at location are empty\neditor.api.isEmpty(at, { after: true }) // Check if text after location is empty\neditor.api.isEmpty(at, { block: true }) // Check if block above location is empty\n```\n\n<API name=\"isEmpty\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At | null\" optional>\n    The location to check for emptiness. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorEmptyOptions\" optional>\n    Options for determining emptiness.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorEmptyOptions\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional />\n  <APIItem name=\"after\" type=\"boolean\" optional>\n    Check if text after selection is empty.\n  </APIItem>\n  <APIItem name=\"block\" type=\"boolean\" optional>\n    Check if the block above location is empty.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"boolean\" />\n</API>\n\n### `isEnd`\n\nCheck if a point is the end point of a location.\n\n<API name=\"isEnd\">\n<APIParameters>\n  <APIItem name=\"point\" type=\"Point\">\n    The point to check.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to check against. Defaults to current selection.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the point is the end point of the location, false otherwise.\n</APIReturns>\n</API>\n\n### `isExpanded`\n\nCheck if the selection is expanded (start and end points are different).\n\n<API name=\"isExpanded\">\n<APIReturns type=\"boolean\">\n  True if the selection is expanded, false otherwise.\n</APIReturns>\n</API>\n\n### `isNormalizing`\n\nCheck if the editor is currently normalizing after each operation.\n\n<API name=\"isNormalizing\">\n<APIReturns type=\"boolean\">\n  True if the editor is currently normalizing, false otherwise.\n</APIReturns>\n</API>\n\n### `isStart`\n\nCheck if a point is the start point of a location.\n\n<API name=\"isStart\">\n<APIParameters>\n  <APIItem name=\"point\" type=\"Point\">\n    The point to check.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to check against. Defaults to current selection.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the point is the start point of the location, false otherwise.\n</APIReturns>\n</API>\n\n### `isSelected`\n\nCheck if a path is selected by the current selection.\n\n<API name=\"isSelected\">\n<APIParameters>\n  <APIItem name=\"target\" type=\"Path | TRange\">\n    The path or range to check.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorIsSelectedOptions\" optional>\n    Options for checking selection.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorIsSelectedOptions\">\n  <APIItem name=\"contains\" type=\"boolean\" optional>\n    Check if selection contains the entire path range.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"boolean\">\n  True if the path is selected, false otherwise.\n</APIReturns>\n</API>\n\n### `leaf`\n\nGet the leaf text node at a location.\n\n<API name=\"leaf\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\">\n    The location to get the leaf from.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorLeafOptions\" optional>\n    Options for getting the leaf.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorLeafOptions\">\n  <APIItem name=\"depth\" type=\"number\" optional>\n    The depth to traverse to find the leaf.\n  </APIItem>\n  <APIItem name=\"edge\" type=\"LeafEdge\" optional>\n    Which edge of the location to get the leaf from (`'start' | 'end'`).\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<TextIn<V>> | undefined\">\n  A tuple containing the leaf text node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n### `levels`\n\nIterate through all levels at a location. This includes all ancestors up to the root editor node.\n\n<API name=\"levels\">\n<APIOptions type=\"EditorLevelsOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options for matching levels.\n  </APIItem>\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    Whether to traverse in reverse order (bottom-up vs. top-down).\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the traversal.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Generator<NodeEntry<NodeIn<V>>, void, undefined>\">\n  A generator that yields tuples of [node, path] for each ancestor level.\n</APIReturns>\n</API>\n\n### `last`\n\nGet the last node at a location.\n\n<API name=\"last\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\">\n    The location to get the last node from.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorLastOptions\" optional>\n    Options for getting the last node.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorLastOptions\">\n  <APIItem name=\"level\" type=\"number\" optional>\n    Get last node at this level (0-based).\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<DescendantIn<V>> | undefined\">\n  A tuple containing the last node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n### `mark`\n\nReturns the selection mark value by key.\n\n<API name=\"mark\">\n<APIParameters>\n  <APIItem name=\"key\" type=\"keyof MarksIn<V>\">\n    The mark key.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"MarksIn<V>[K] | null | undefined\">\n  The mark value if it exists, null if not set, or undefined if multiple different values exist.\n</APIReturns>\n</API>\n\n### `marks`\n\nGet the marks that would be added to text at the current selection.\n\n<API name=\"marks\">\n<APIReturns type=\"MarksIn<V> | null\">\n  The marks at the current selection, or null if there are no marks.\n</APIReturns>\n</API>\n\n### `next`\n\nGet the matching node in the branch of the document after a location.\n\n<API name=\"next\">\n<APIOptions type=\"EditorNextOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options for matching nodes.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At | Span\" optional>\n    The location to start searching from. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode for matching nodes.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n  <APIItem name=\"from\" type=\"'after' | 'child'\" optional>\n    - `'after'`: Start from point after current location\n    - `'child'`: Start from the first child of current path\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<DescendantIn<V>> | undefined\">\n  A tuple containing the next matching node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n\n### `node`\n\nGet the node at a location or find the first node that matches options.\n\n<API name=\"node\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to get a node from.\n  </APIItem>\n  <APIItem name=\"nodeOptions\" type=\"EditorNodeOptions\" optional>\n    Options for getting a node.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorNodeOptions\">\n  <APIItem name=\"depth\" type=\"number\" optional>\n    The depth to traverse to find the node.\n  </APIItem>\n  <APIItem name=\"edge\" type=\"'start' | 'end'\" optional>\n    Which edge of the location to get the node from.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<NodeIn<V>> | undefined\">\n  A tuple containing the matching node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n### `nodes`\n\nIterate through all nodes in the editor that match the given options.\n\n<API name=\"nodes\">\n<APIOptions type=\"EditorNodesOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options for matching nodes.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At | Span\" optional>\n    Where to start iterating. Defaults to editor selection.\n  </APIItem>\n  <APIItem name=\"ignoreNonSelectable\" type=\"boolean\" optional>\n    Whether to ignore non-selectable nodes during traversal.\n  </APIItem>\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    Whether to traverse in reverse order.\n  </APIItem>\n  <APIItem name=\"universal\" type=\"boolean\" optional>\n    Whether to ensure the operation works universally across all nodes.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    - `'all'`: Return all matching nodes\n    - `'highest'`: Return highest-level matching nodes\n    - `'lowest'`: Return lowest-level matching nodes\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Generator<NodeEntry<DescendantIn<V>>, void, undefined>\">\n  A generator that yields tuples of [node, path] for each matching node.\n</APIReturns>\n</API>\n\n### `parent`\n\nGet the parent node of a location.\n\n<API name=\"parent\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to get the parent from.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorParentOptions\" optional>\n    Options for getting the parent node.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorParentOptions\">\n  <APIItem name=\"depth\" type=\"number\" optional>\n    Number of levels to traverse up to find the parent.\n  </APIItem>\n  <APIItem name=\"edge\" type=\"'start' | 'end'\" optional>\n    Which edge of the location to get the parent from.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<AncestorIn<V>> | undefined\">\n  A tuple containing the parent node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n### `previous`\n\nGet the matching node in the branch of the document before a location.\n\n<API name=\"previous\">\n<APIOptions type=\"EditorPreviousOptions<V>\">\n  <APIItem name=\"...options\" type=\"QueryOptions<V>\" optional>\n    Common query options for matching nodes.\n  </APIItem>\n  <APIItem name=\"at\" type=\"At | Span\" optional>\n    The location to start searching from. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode for matching nodes.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n  <APIItem name=\"sibling\" type=\"boolean\" optional>\n    Whether to get the previous sibling node instead of any previous node.\n  </APIItem>\n  <APIItem name=\"from\" type=\"'before' | 'parent'\" optional>\n    - `'before'`: Start from point before current location\n    - `'parent'`: Start from parent of current location\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<DescendantIn<V>> | undefined\">\n  A tuple containing the previous matching node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n### `prop`\n\nGet a property value from a list of nodes. Returns `undefined` if the property value is not consistent across all nodes.\n\n<API name=\"prop\">\n<APIOptions type=\"EditorPropOptions<V>\">\n  <APIItem name=\"nodes\" type=\"TElement[]\">\n    The list of nodes to get the property value from.\n  </APIItem>\n  <APIItem name=\"key\" type=\"string\" optional>\n    The property key to get from the nodes.\n  </APIItem>\n  <APIItem name=\"defaultValue\" type=\"string\" optional>\n    Default value to return if property is not found.\n  </APIItem>\n  <APIItem name=\"getProp\" type=\"(node: DescendantIn<V>) => any\" optional>\n    Custom function to extract property value from a node.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"'all' | 'block' | 'text'\" optional>\n    - `'all'`: Get property from all nodes\n    - `'block'`: Get property from the first block node\n    - `'text'`: Get property from the first text node\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"string | undefined\">\n  The consistent property value across all nodes, or `undefined` if values differ.\n</APIReturns>\n</API>\n\n### `string`\n\nGet the text string content of a location.\n\n<API name=\"string\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to get text content from. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorStringOptions\" optional>\n    Options for getting text content.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorStringOptions\">\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include text content from void nodes.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"string\">\n  The text content at the specified location.\n</APIReturns>\n</API>\n\n### `void`\n\nMatch a void node in the current branch of the editor.\n\n<API name=\"void\">\n<APIOptions type=\"EditorVoidOptions\">\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to search from. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode for matching nodes.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"NodeEntry<ElementIn<V>> | undefined\">\n  A tuple containing the void node and its path, or undefined if not found.\n</APIReturns>\n</API>\n\n## Location\n\n### `findPath`\n\nFind the path of a Plate node in the editor.\n\n<API name=\"findPath\">\n<APIParameters>\n  <APIItem name=\"node\" type=\"TNode\">\n    The node to find the path for in the editor tree.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorFindPathOptions\" optional>\n    Options for finding the node's path.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorFindPathOptions\">\n  <APIItem name=\"...options\" type=\"QueryOptions<Value>\" optional>\n    Common query options for finding nodes.\n  </APIItem>\n  <APIItem name=\"ignoreNonSelectable\" type=\"boolean\" optional>\n    Whether to ignore non-selectable nodes during traversal.\n  </APIItem>\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    Whether to traverse in reverse order.\n  </APIItem>\n  <APIItem name=\"universal\" type=\"boolean\" optional>\n    Whether to ensure the operation works universally across all nodes.\n  </APIItem>\n  <APIItem name=\"mode\" type=\"QueryMode\" optional>\n    Query mode for finding nodes.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include void nodes in the search.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Path | undefined\">\n  The path of the node if found, undefined otherwise.\n</APIReturns>\n</API>\n\n### `path`\n\nGet the path of a location.\n\n<API name=\"path\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to get the path from. Defaults to current selection.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path\">\n  The path of the location.\n</APIReturns>\n</API>\n\n### `point`\n\nGet the `start` or `end` (default is `start`) point of a location.\n\n<API name=\"point\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to get the point from. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorPointOptions\" optional>\n    Options for getting the point.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorPointOptions\">\n  <APIItem name=\"edge\" type=\"'start' | 'end'\" optional>\n    Which edge of the location to get the point from.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Point\">\n  The point at the specified location and edge.\n</APIReturns>\n</API>\n\n### `positions`\n\nIterate through all possible point positions in the document.\n\n<API name=\"positions\">\n<APIOptions type=\"EditorPositionsOptions\">\n  <APIItem name=\"at\" type=\"At\" optional>\n    Where to start iterating. Defaults to editor selection.\n  </APIItem>\n  <APIItem name=\"unit\" type=\"TextUnitAdjustment\" optional>\n    - `'offset'`: Moves to the next offset Point\n    - `'character'`: Moves to the next character\n    - `'word'`: Moves to the position after the next word\n    - `'line'` | 'block': Moves between block boundaries\n  </APIItem>\n  <APIItem name=\"reverse\" type=\"boolean\" optional>\n    When true returns positions in reverse order.\n  </APIItem>\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Whether to include positions inside void nodes.\n  </APIItem>\n  <APIItem name=\"ignoreNonSelectable\" type=\"boolean\" optional>\n    Whether to skip positions in non-selectable nodes.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Generator<Point, void, undefined>\">\n  A generator that yields each valid point position in the document.\n</APIReturns>\n</API>\n\n### `nodesRange`\n\nReturns the range spanning the given node entries.\n\n<API name=\"nodesRange\">\n<APIParameters>\n  <APIItem name=\"nodes\" type=\"NodeEntry[]\">\n    The node entries to get the range for.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"TRange | undefined\">\n  The range spanning the nodes, or undefined if no valid range can be created.\n</APIReturns>\n</API>\n\n### `range`\n\nCreate a range between two locations.\n\n<API name=\"range\">\n<APIOptions type=\"EditorRangeOptions\">\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to create the range at. Defaults to current selection.\n  </APIItem>\n  <APIItem name=\"focus\" type=\"Point\" optional>\n    The focus (end) point of the range.\n  </APIItem>\n  <APIItem name=\"anchor\" type=\"Point\" optional>\n    The anchor (start) point of the range.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"TRange\">\n  A new range between the specified points.\n</APIReturns>\n</API>\n\n### `start`\n\nGet the start point of a location.\n\n<API name=\"start\">\n<APIParameters>\n  <APIItem name=\"at\" type=\"At\" optional>\n    The location to get the start point from.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorStartOptions\" optional>\n    Options for getting the start point.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorStartOptions\">\n  <APIItem name=\"next\" type=\"boolean\" optional>\n    Get the start point of the next node instead of the current one.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Point\">\n  The start point of the location.\n</APIReturns>\n</API>\n\n### `unhangRange`\n\nConvert a range into a non-hanging one.\n\nA \"hanging\" range is one created by the browser's \"triple-click\" selection behavior. When triple-clicking a block, the browser selects from the start of that block to the start of the _next_ block. The range thus \"hangs over\" into the next block. If `unhangRange` is given such a range, it moves the end backwards until it's in a non-empty text node that precedes the hanging block.\n\nNote that `unhangRange` is designed for the specific purpose of fixing triple-clicked blocks, and therefore currently has a number of caveats:\n\n- It does not modify the start of the range; only the end. For example, it does not \"unhang\" a selection that starts at the end of a previous block.\n- It only does anything if the start block is fully selected. For example, it does not handle ranges created by double-clicking the end of a paragraph (which browsers treat by selecting from the end of that paragraph to the start of the next).\n\n<API name=\"unhangRange\">\n<APIParameters>\n  <APIItem name=\"range\" type=\"TRange\">\n    The range to unhang.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorUnhangRangeOptions\" optional>\n    Options for un-hanging the range.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorUnhangRangeOptions\">\n  <APIItem name=\"voids\" type=\"boolean\" optional>\n    Allow placing the end of the selection in a void node.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"TRange\">\n  A new range with the end point moved backwards if it was hanging.\n</APIReturns>\n</API>\n\n## Element\n\n### `elementReadOnly`\n\nCheck if an element is read-only.\n\n<API name=\"elementReadOnly\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"ElementIn<V>\">\n    The element to check for read-only status.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element is read-only, false otherwise.\n</APIReturns>\n</API>\n\n### `isBlock`\n\nCheck if a value is a block `Element` object.\n\n<API name=\"isBlock\">\n<APIParameters>\n  <APIItem name=\"value\" type=\"any\">\n    The value to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the value is a block element, false otherwise.\n</APIReturns>\n</API>\n\n### `isInline`\n\nCheck if a value is an inline `Element` object.\n\n<API name=\"isInline\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"DescendantIn<V>\">\n    The element to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element is inline, false otherwise.\n</APIReturns>\n</API>\n\n### `isSelectable`\n\nCheck if a value is a selectable `Element` object.\n\n<API name=\"isSelectable\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"ElementIn<V>\">\n    The element to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element is selectable, false otherwise.\n</APIReturns>\n</API>\n\n### `isVoid`\n\nCheck if an element is void.\n\n<API name=\"isVoid\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"ElementIn<V>\">\n    The element to check for void status.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element is void, false otherwise.\n</APIReturns>\n</API>\n\n### `markableVoid`\n\nCheck if an element is a markable void element.\n\n<API name=\"markableVoid\">\n<APIParameters>\n  <APIItem name=\"element\" type=\"ElementIn<V>\">\n    The element to check for markable void status.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the element is a markable void element, false otherwise.\n</APIReturns>\n</API>\n\n## Ref\n\n### `pathRef`\n\nCreate a mutable ref for a `Path`.\n\n<API name=\"pathRef\">\n<APIParameters>\n  <APIItem name=\"path\" type=\"Path\">\n    The path to reference.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorPathRefOptions\" optional>\n    Options for the path reference.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorPathRefOptions\">\n  <APIItem name=\"affinity\" type=\"TextDirection | null\" optional>\n    The direction to resolve the ref when ambiguous:\n    - `'forward'`: Resolve to the next valid position\n    - `'backward'`: Resolve to the previous valid position\n    - `null`: Do not resolve to any position\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"PathRef\">\n  A mutable reference that updates its path as operations are applied to the editor.\n</APIReturns>\n</API>\n\n### `pathRefs`\n\nGet the set of currently tracked path refs of the editor.\n\n<API name=\"pathRefs\">\n<APIReturns type=\"Set<PathRef>\">\n  The set of tracked path refs.\n</APIReturns>\n</API>\n\n### `pointRef`\n\nCreate a mutable ref for a `Point`.\n\n<API name=\"pointRef\">\n<APIParameters>\n  <APIItem name=\"point\" type=\"Point\">\n    The point to reference.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorPointRefOptions\" optional>\n    Options for the point reference.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorPointRefOptions\">\n  <APIItem name=\"affinity\" type=\"TextDirection | null\" optional>\n    The direction to resolve the ref when ambiguous:\n    - `'forward'`: Resolve to the next valid position\n    - `'backward'`: Resolve to the previous valid position\n    - `null`: Do not resolve to any position\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"PointRef\">\n  A mutable reference that updates its point as operations are applied to the editor.\n</APIReturns>\n</API>\n\n### `pointRefs`\n\nGet the set of currently tracked point refs of the editor.\n\n<API name=\"pointRefs\">\n<APIReturns type=\"Set<PointRef>\">\n  The set of tracked point refs.\n</APIReturns>\n</API>\n\n### `rangeRef`\n\nCreate a mutable ref for a `Range`.\n\n<API name=\"rangeRef\">\n<APIParameters>\n  <APIItem name=\"range\" type=\"TRange\">\n    The range to reference.\n  </APIItem>\n  <APIItem name=\"options\" type=\"EditorRangeRefOptions\" optional>\n    Options for the range reference.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"EditorRangeRefOptions\">\n  <APIItem name=\"affinity\" type=\"RangeDirection | null\" optional>\n    The direction to resolve the ref when ambiguous:\n    - `'forward'`: Resolve both points forward\n    - `'backward'`: Resolve both points backward\n    - `'outward'`: Resolve start backward and end forward\n    - `'inward'`: Resolve start forward and end backward\n    - `null`: Do not resolve to any position\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"RangeRef\">\n  A mutable reference that updates its range as operations are applied to the editor.\n</APIReturns>\n</API>\n\n### `rangeRefs`\n\nGet the set of currently tracked range refs of the editor.\n\n<API name=\"rangeRefs\">\n<APIReturns type=\"Set<RangeRef>\">\n  The set of tracked range refs.\n</APIReturns>\n</API>\n\n## DOM\n\n### `findDocumentOrShadowRoot`\n\nFind the document or shadow root from the editor.\n\n<API name=\"findDocumentOrShadowRoot\">\n<APIReturns type=\"Document | ShadowRoot\">\n  The document or shadow root containing the editor.\n</APIReturns>\n</API>\n\n### `findEventRange`\n\nGet the target range from a DOM event.\n\n<API name=\"findEventRange\">\n<APIParameters>\n  <APIItem name=\"event\" type=\"Event\">\n    The DOM event to get the range from.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"TRange | null\">\n  The range at the event target, or null if no valid range found.\n</APIReturns>\n</API>\n\n### `findKey`\n\nFind a key for a Plate node. Returns an instance of `Key` which looks like `{ id: string }`.\n\n<API name=\"findKey\">\n<APIParameters>\n  <APIItem name=\"node\" type=\"TNode\">\n    The node to find the key for.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Key\">\n  The key associated with the node.\n</APIReturns>\n</API>\n\n### `getWindow`\n\nGet the window object from the editor.\n\n<API name=\"getWindow\">\n<APIReturns type=\"Window\">\n  The window object associated with the editor.\n</APIReturns>\n</API>\n\n### `hasDOMNode`\n\nCheck if a DOM node is within the editor.\n\n<API name=\"hasDOMNode\">\n<APIParameters>\n  <APIItem name=\"target\" type=\"Node\">\n    The DOM node to check.\n  </APIItem>\n  <APIItem name=\"options\" type=\"object\" optional>\n    Options for checking the DOM node.\n  </APIItem>\n</APIParameters>\n<APIOptions type=\"object\">\n  <APIItem name=\"editable\" type=\"boolean\" optional>\n    Whether to check if the node is in an editable element.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"boolean\">\n  True if the DOM node is within the editor, false otherwise.\n</APIReturns>\n</API>\n\n### `hasEditableTarget`\n\nCheck if a DOM target is editable.\n\n<API name=\"hasEditableTarget\">\n<APIParameters>\n  <APIItem name=\"target\" type=\"EventTarget | null\">\n    The DOM target to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"target is Node\">\n  True if the target is editable, false otherwise.\n</APIReturns>\n</API>\n\n### `hasRange`\n\nCheck if the editor has a range.\n\n<API name=\"hasRange\">\n<APIParameters>\n  <APIItem name=\"range\" type=\"TRange\">\n    The range to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the editor has the specified range, false otherwise.\n</APIReturns>\n</API>\n\n### `hasSelectableTarget`\n\nCheck if a DOM target is selectable.\n\n<API name=\"hasSelectableTarget\">\n<APIParameters>\n  <APIItem name=\"target\" type=\"EventTarget | null\">\n    The DOM target to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"target is Node\">\n  True if the target is selectable, false otherwise.\n</APIReturns>\n</API>\n\n### `hasTarget`\n\nCheck if a DOM target exists.\n\n<API name=\"hasTarget\">\n<APIParameters>\n  <APIItem name=\"target\" type=\"EventTarget | null\">\n    The DOM target to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"target is Node\">\n  True if the target exists, false otherwise.\n</APIReturns>\n</API>\n\n### `isComposing`\n\nCheck if the user is currently composing inside the editor.\n\n<API name=\"isComposing\">\n<APIReturns type=\"boolean\">\n  True if the user is currently composing text, false otherwise.\n</APIReturns>\n</API>\n\n### `isFocused`\n\nCheck if the editor is focused.\n\n<API name=\"isFocused\">\n<APIReturns type=\"boolean\">\n  True if the editor has focus, false otherwise.\n</APIReturns>\n</API>\n\n### `isReadOnly`\n\nCheck if the editor is in read-only mode.\n\n<API name=\"isReadOnly\">\n<APIReturns type=\"boolean\">\n  True if the editor is read-only, false otherwise.\n</APIReturns>\n</API>\n\n### `toDOMNode`\n\nFind the native DOM element from a Plate node.\n\n<API name=\"toDOMNode\">\n<APIOptions type=\"TNode\">\n  <APIItem name=\"node\" type=\"TNode\">\n    The Plate node to convert to a DOM element.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"HTMLElement\">\n  The corresponding DOM element for the Plate node.\n</APIReturns>\n</API>\n\n### `toDOMPoint`\n\nFind a native DOM selection point from a Plate point.\n\n<API name=\"toDOMPoint\">\n<APIOptions type=\"Point\">\n  <APIItem name=\"point\" type=\"Point\">\n    The Plate point to convert to a DOM point.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"DOMPoint\">\n  A tuple of [node, offset] representing the DOM point.\n</APIReturns>\n</API>\n\n### `toDOMRange`\n\nFind a native DOM range from a Plate range.\n\n<API name=\"toDOMRange\">\n<APIOptions type=\"TRange\">\n  <APIItem name=\"range\" type=\"TRange\">\n    The Plate range to convert to a DOM range.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"DOMRange\">\n  The corresponding DOM range for the Plate range.\n</APIReturns>\n</API>\n\n### `toSlateNode`\n\nFind a Plate node from a native DOM element.\n\n<API name=\"toSlateNode\">\n<APIOptions type=\"DOMNode\">\n  <APIItem name=\"domNode\" type=\"DOMNode\">\n    The DOM node to convert to a Plate node.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"TNode | undefined\">\n  The corresponding Plate node if found, undefined otherwise.\n</APIReturns>\n</API>\n\n### `toSlatePoint`\n\nFind a Plate point from a DOM selection point.\n\n<API name=\"toSlatePoint\">\n<APIOptions type=\"DOMPoint\">\n  <APIItem name=\"domPoint\" type=\"DOMPoint\">\n    The DOM point to convert to a Plate point.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"Point | undefined\">\n  The corresponding Plate point if found, undefined otherwise.\n</APIReturns>\n</API>\n\n### `toSlateRange`\n\nFind a Plate range from a DOM range.\n\n<API name=\"toSlateRange\">\n<APIOptions type=\"DOMRange\">\n  <APIItem name=\"domRange\" type=\"DOMRange\">\n    The DOM range to convert to a Plate range.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"TRange | undefined\">\n  The corresponding Plate range if found, undefined otherwise.\n</APIReturns>\n</API>\n\n## Callback\n\n### `onChange`\n\nCalled when there is a change in the editor.\n\n<API name=\"onChange\">\n<APIOptions type=\"object\">\n  <APIItem name=\"operation\" type=\"Operation\" optional>\n    The operation that triggered the change.\n  </APIItem>\n</APIOptions>\n</API>\n\n## Core\n\n### `getDirtyPaths`\n\nGet the paths that need to be normalized after an operation.\n\n<API name=\"getDirtyPaths\">\n<APIParameters>\n  <APIItem name=\"operation\" type=\"Operation<N extends DescendantIn<V>>\">\n    The operation that triggered normalization.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"Path[]\">\n  An array of paths that need to be normalized after the operation.\n</APIReturns>\n</API>\n\n### `shouldNormalizeNode`\n\nOverride this method to prevent normalizing a specific node. Defaults to returning `true`.\n\n<API name=\"shouldNormalizeNode\">\n<APIParameters>\n  <APIItem name=\"entry\" type=\"NodeEntry\">\n    The node entry (node and path) to check.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"boolean\">\n  True if the node should be normalized, false otherwise.\n</APIReturns>\n</API>\n\n### `setNormalizing`\n\nManually control the editor's normalizing state.\n\n<API name=\"setNormalizing\">\n<APIOptions type=\"boolean\">\n  <APIItem name=\"isNormalizing\" type=\"boolean\">\n    Whether the editor should normalize after each operation.\n  </APIItem>\n</APIOptions>\n</API>\n\n### `shouldNormalize`\n\nControls whether the editor should normalize after an operation. Override this method to prevent normalizing in certain situations.\n\n<API name=\"shouldNormalize\">\n<APIOptions type=\"object\">\n  <APIItem name=\"dirtyPaths\" type=\"Path[]\">\n    The paths that need to be normalized.\n  </APIItem>\n  <APIItem name=\"initialDirtyPathsLength\" type=\"number\">\n    The initial number of dirty paths before normalization started.\n  </APIItem>\n  <APIItem name=\"iteration\" type=\"number\">\n    The current normalization iteration count.\n  </APIItem>\n  <APIItem name=\"operation\" type=\"Operation\" optional>\n    The operation that triggered the normalization.\n  </APIItem>\n</APIOptions>\n\n<APIReturns type=\"boolean\">\n  True if the editor should normalize, false otherwise.\n</APIReturns>\n</API>\n\n## History\n\n### `isMerging`\n\nGet the merge flag's current value.\n\n<API name=\"isMerging\">\n<APIReturns type=\"boolean\">\n  True if the editor is currently merging operations, false otherwise.\n</APIReturns>\n</API>\n\n### `isSaving`\n\nGet the saving flag's current value.\n\n<API name=\"isSaving\">\n<APIReturns type=\"boolean\">\n  True if the editor is currently saving, false otherwise.\n</APIReturns>\n</API>\n\n### `isSplittingOnce`\n\nGet the splitting flag's current value.\n\n<API name=\"isSplittingOnce\">\n<APIReturns type=\"boolean\">\n  True if the editor is currently performing a single split operation, false otherwise.\n</APIReturns>\n</API>\n\n## Utils\n\n### `create.block`\n\nDefault block factory for creating new block elements.\n\n<API name=\"create.block\">\n<APIParameters>\n  <APIItem name=\"node\" type=\"Partial<TElement>\" optional>\n    Partial element properties to merge into the new block.\n  </APIItem>\n  <APIItem name=\"path\" type=\"Path\" optional>\n    Path for the new block.\n  </APIItem>\n</APIParameters>\n\n<APIReturns type=\"TElement\">\n  A new block element.\n</APIReturns>\n</API>\n\n### `create.value`\n\nDefault value factory for creating new editor values.\n\n<API name=\"create.value\">\n<APIReturns type=\"Value\">\n  A new editor value.\n</APIReturns>\n</API>\n",
    "code": "var Component=(()=>{var y=Object.create;var d=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var E=(l,n)=>()=>(n||l((n={exports:{}}).exports,n),n.exports),N=(l,n)=>{for(var t in n)d(l,t,{get:n[t],enumerable:!0})},h=(l,n,t,i)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of f(n))!k.call(l,r)&&r!==t&&d(l,r,{get:()=>n[r],enumerable:!(i=g(n,r))||i.enumerable});return l};var v=(l,n,t)=>(t=l!=null?y(b(l)):{},h(n||!l||!l.__esModule?d(t,\"default\",{value:l,enumerable:!0}):t,l)),T=l=>h(d({},\"__esModule\",{value:!0}),l);var p=E((A,s)=>{s.exports=_jsx_runtime});var F={};N(F,{default:()=>m,frontmatter:()=>w});var e=v(p()),w={title:\"Editor API\",description:\"API reference for the Editor API.\"};function u(l){let n={a:\"a\",br:\"br\",code:\"code\",div:\"div\",em:\"em\",h2:\"h2\",h3:\"h3\",li:\"li\",p:\"p\",pre:\"pre\",span:\"span\",ul:\"ul\",...l.components},{API:t,APIItem:i,APIOptions:r,APIParameters:o,APIReturns:a}=n;return t||c(\"API\",!0),i||c(\"APIItem\",!0),r||c(\"APIOptions\",!0),o||c(\"APIParameters\",!0),a||c(\"APIReturns\",!0),(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"The Editor API provides a set of helper functions for querying and manipulating the editor state.\"}),`\n`,(0,e.jsxs)(n.h2,{id:\"common-options\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#common-options\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Common Options\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"at\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#at\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"At\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"A location reference in the editor. Can be either a Location or a Node.\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`type At = TLocation | TNode\n`,children:(0,e.jsx)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\"type\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\" At\"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\" =\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\" TLocation\"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\" |\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\" TNode\"})]})})})}),`\n`,(0,e.jsxs)(n.p,{children:[\"When a Node is passed, its path will be found using \",(0,e.jsx)(n.a,{href:\"/docs/api/slate/editor-api#findpath\",children:(0,e.jsx)(n.code,{children:\"editor.api.findPath()\"})}),\". This allows you to reference a location by either:\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"A \",(0,e.jsx)(n.a,{href:\"/docs/api/slate/location\",children:\"Location\"}),\" (\",(0,e.jsx)(n.a,{href:\"/docs/api/slate/path\",children:\"Path\"}),\", \",(0,e.jsx)(n.a,{href:\"/docs/api/slate/point\",children:\"Point\"}),\", or \",(0,e.jsx)(n.a,{href:\"/docs/api/slate/range\",children:\"Range\"}),\")\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"A \",(0,e.jsx)(n.a,{href:\"/docs/api/slate/node\",children:\"Node\"})]}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"Example:\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`// Using a location\neditor.api.nodes({ at: [0, 0] }) // Path location\neditor.api.nodes({ at: { path: [0], offset: 0 } }) // Point location \neditor.api.nodes({ at: { anchor: point1, focus: point2 } }) // Range location\n\n// Using a node reference\nconst node = editor.children[0]\neditor.api.nodes({ at: node }) // Will find node's path internally\n`,children:(0,e.jsxs)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Using a location\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ at: [\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\", \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"] }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Path location\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ at: { path: [\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"], offset: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" } }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Point location \"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ at: { anchor: point1, focus: point2 } }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Range location\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:\" \"}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Using a node reference\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\"const\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\" node\"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\" =\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" editor.children[\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"]\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ at: node }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Will find node's path internally\"})]})]})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"match\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#match\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Match\"]}),`\n`,(0,e.jsx)(n.p,{children:\"A predicate for matching nodes. The predicate can be either:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"A function that takes a \",(0,e.jsx)(n.code,{children:\"node\"}),\" and its \",(0,e.jsx)(n.code,{children:\"path\"}),\" and returns a \",(0,e.jsx)(n.code,{children:\"boolean\"})]}),`\n`,(0,e.jsxs)(n.li,{children:[\"An object where each key-value pair must match the node's properties\",`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Values can be single values or arrays of values to match against\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"Example:\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`// Function predicate\neditor.api.nodes({\n  match: (node) => node.type === 'p'\n})\n\n// Object predicate\neditor.api.nodes({\n  match: { type: 'p' }\n})\n\n// Object predicate with multiple possible values\neditor.api.nodes({\n  match: { type: ['p', 'h1'] }\n})\n`,children:(0,e.jsxs)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Function predicate\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"  match\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\": (\"}),(0,e.jsx)(n.span,{style:{color:\"#FFAB70\"},children:\"node\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\") \"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\"=>\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" node.type \"}),(0,e.jsx)(n.span,{style:{color:\"#F97583\"},children:\"===\"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\" 'p'\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"})\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:\" \"}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Object predicate\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"  match: { type: \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'p'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"})\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:\" \"}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Object predicate with multiple possible values\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"  match: { type: [\"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'p'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\", \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'h1'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"] }\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"})\"})})]})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"querymode\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#querymode\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"QueryMode\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Mode for querying nodes in a hierarchy.\"}),`\n`,(0,e.jsx)(t,{name:\"QueryMode\",children:(0,e.jsx)(r,{type:\"QueryMode\",children:(0,e.jsxs)(i,{name:\"mode\",type:\"'all' | 'highest' | 'lowest'\",optional:!0,children:[(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'all'\"}),\" (default): Return all matching nodes\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'highest'\"}),\": In a hierarchy of nodes, only return the highest-level matching nodes\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'lowest'\"}),\": In a hierarchy of nodes, only return the lowest-level matching nodes\"]}),`\n`]}),(0,e.jsx)(n.p,{children:\"Example:\"}),(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`// Given this structure:\n// - blockquote (matches)\n//   - paragraph (matches)\n//     - text\n\n// mode: 'all' returns both blockquote and paragraph\neditor.api.nodes({ match: { type: ['blockquote', 'paragraph'] }, mode: 'all' })\n\n// mode: 'highest' returns only blockquote\neditor.api.nodes({ match: { type: ['blockquote', 'paragraph'] }, mode: 'highest' })\n\n// mode: 'lowest' returns only paragraph\neditor.api.nodes({ match: { type: ['blockquote', 'paragraph'] }, mode: 'lowest' })\n`,children:(0,e.jsxs)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Given this structure:\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// - blockquote (matches)\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"//   - paragraph (matches)\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"//     - text\"})}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:\" \"}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// mode: 'all' returns both blockquote and paragraph\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ match: { type: [\"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'blockquote'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\", \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'paragraph'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"] }, mode: \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'all'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" })\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:\" \"}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// mode: 'highest' returns only blockquote\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ match: { type: [\"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'blockquote'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\", \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'paragraph'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"] }, mode: \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'highest'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" })\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:\" \"}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// mode: 'lowest' returns only paragraph\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"nodes\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ match: { type: [\"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'blockquote'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\", \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'paragraph'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"] }, mode: \"}),(0,e.jsx)(n.span,{style:{color:\"#9ECBFF\"},children:\"'lowest'\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" })\"})]})]})})})]})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"queryoptions\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#queryoptions\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"QueryOptions\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Common options for querying nodes in the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"QueryOptions\",children:(0,e.jsxs)(r,{type:\"QueryOptions<V>\",children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Where to start querying from. Defaults to current editor selection.\"})}),(0,e.jsx)(i,{name:\"block\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Match block nodes. When true, only matches block elements.\"})}),(0,e.jsxs)(i,{name:\"empty\",type:\"boolean\",optional:!0,children:[(0,e.jsx)(n.p,{children:\"Match empty/non-empty nodes.\"}),(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"When true, matches only empty nodes\"}),`\n`,(0,e.jsx)(n.li,{children:\"When false, matches only non-empty nodes\"}),`\n`]})]}),(0,e.jsxs)(i,{name:\"id\",type:\"boolean | string\",optional:!0,children:[(0,e.jsx)(n.p,{children:\"Match the node by id.\"}),(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"When true, matches all nodes with an id\"}),`\n`,(0,e.jsx)(n.li,{children:\"When string, matches nodes with that specific id\"}),`\n`]})]}),(0,e.jsxs)(i,{name:\"match\",type:\"Predicate<NodeIn<V>>\",optional:!0,children:[(0,e.jsx)(n.p,{children:\"Custom function or object to match nodes.\"}),(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"Function: \",(0,e.jsx)(n.code,{children:\"(node, path) => boolean\"})]}),`\n`,(0,e.jsx)(n.li,{children:\"Object: Key-value pairs that should match the node\"}),`\n`]})]}),(0,e.jsx)(i,{name:\"text\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Match text nodes. When true, matches only text nodes.\"})})]})}),`\n`,(0,e.jsxs)(n.h2,{id:\"editorapi\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#editorapi\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"editor.api\"})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"above\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#above\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"above\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the matching ancestor above a location in the document.\"}),`\n`,(0,e.jsxs)(t,{name:\"above\",children:[(0,e.jsxs)(r,{type:\"EditorAboveOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode options.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})})]}),(0,e.jsx)(a,{type:\"NodeEntry<N> | undefined\",children:(0,e.jsxs)(n.p,{children:[\"A tuple containing the matching ancestor node and its path, or \",(0,e.jsx)(n.code,{children:\"undefined\"}),\" if no match is found.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"block\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#block\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"block\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Get the block at a location or find the first block that matches options.\",(0,e.jsx)(n.br,{}),`\n`,\"Blocks are typically top-level nodes, so this is a common way to retrieve the ancestor block.\"]}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`editor.api.block() // Get block above selection\neditor.api.block({ above: true }) // Get block above selection\neditor.api.block({ at: [0, 0] }) // Get block at [0, 0]\neditor.api.block({ at: [0, 0], above: true }) // Get block at [0]\neditor.api.block({ highest: true }) // Get highest block at selection\n`,children:(0,e.jsxs)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:[(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"block\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"() \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Get block above selection\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"block\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ above: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Get block above selection\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"block\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ at: [\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\", \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"] }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Get block at [0, 0]\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"block\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ at: [\"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\", \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"0\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"], above: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Get block at [0]\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"block\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ highest: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Get highest block at selection\"})]})]})})}),`\n`,(0,e.jsxs)(t,{name:\"block\",children:[(0,e.jsxs)(r,{type:\"EditorBlockOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for matching blocks.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At | Span\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to query at. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"ignoreNonSelectable\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ignore non-selectable nodes during traversal.\"})}),(0,e.jsx)(i,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to traverse in reverse order.\"})}),(0,e.jsx)(i,{name:\"universal\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ensure the operation works universally across all nodes.\"})}),(0,e.jsx)(i,{name:\"above\",type:\"boolean\",optional:!0,children:(0,e.jsxs)(n.p,{children:[\"If true, get the block above the location. Ignored if \",(0,e.jsx)(n.code,{children:\"at\"}),\" is not a block path.\"]})}),(0,e.jsx)(i,{name:\"highest\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"If true, get the highest block at the location (root-level block).\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode for matching blocks.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})})]}),(0,e.jsx)(a,{type:\"NodeEntry<N> | undefined\",children:(0,e.jsxs)(n.p,{children:[\"The matching block node entry or \",(0,e.jsx)(n.code,{children:\"undefined\"}),\" if no match is found.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"blocks\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#blocks\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"blocks\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Returns all matching blocks.\"}),`\n`,(0,e.jsxs)(t,{name:\"blocks\",children:[(0,e.jsxs)(r,{type:\"EditorNodesOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for matching blocks.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At | Span\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to query at. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"ignoreNonSelectable\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ignore non-selectable nodes during traversal.\"})}),(0,e.jsx)(i,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to traverse in reverse order.\"})}),(0,e.jsx)(i,{name:\"universal\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ensure the operation works universally across all nodes.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode for matching blocks.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})})]}),(0,e.jsx)(a,{type:\"NodeEntry<ElementIn<V>>[]\",children:(0,e.jsx)(n.p,{children:\"An array of matching block node entries.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"edgeblocks\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#edgeblocks\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"edgeBlocks\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Returns the edge blocks above a location (default: selection).\",(0,e.jsx)(n.br,{}),`\n`,\"Useful for retrieving the start and end block of a range.\"]}),`\n`,(0,e.jsxs)(t,{name:\"edgeBlocks\",children:[(0,e.jsxs)(r,{type:\"EditorNodesOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for matching blocks.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At | Span\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get edge blocks from. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"ignoreNonSelectable\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ignore non-selectable nodes during traversal.\"})}),(0,e.jsx)(i,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to traverse in reverse order.\"})}),(0,e.jsx)(i,{name:\"universal\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ensure the operation works universally across all nodes.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode for matching blocks.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})})]}),(0,e.jsx)(a,{type:\"[NodeEntry<N1>, NodeEntry<N2>] | null\",children:(0,e.jsxs)(n.p,{children:[\"A tuple of \",(0,e.jsx)(n.code,{children:\"[startBlock, endBlock]\"}),\" above the location, or \",(0,e.jsx)(n.code,{children:\"null\"}),\" if not found.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"first\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#first\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"first\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the first node at a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"first\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"at\",type:\"At\",children:(0,e.jsx)(n.p,{children:\"The location to get the first node from.\"})})}),(0,e.jsx)(a,{type:\"NodeEntry<DescendantIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the first node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"fragment\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#fragment\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"fragment\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the fragment at a location or selection.\"}),`\n`,(0,e.jsxs)(t,{name:\"fragment\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At | null\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to extract the fragment from. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorFragmentOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for extracting and processing the fragment.\"})})]}),(0,e.jsx)(a,{type:\"ElementOrTextIn<V>[] | undefined\",children:(0,e.jsx)(n.p,{children:\"The fragment at the location.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"getfragment\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#getfragment\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"getFragment\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Returns the fragment at the current selection. Used when cutting or copying, as an example, to get the fragment at the current selection.\"}),`\n`,(0,e.jsxs)(t,{name:\"getFragment\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get the fragment from. Defaults to current selection.\"})})}),(0,e.jsx)(a,{type:\"ElementOrTextIn<V>[]\",children:(0,e.jsx)(n.p,{children:\"The fragment at the current selection.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hasblocks\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hasblocks\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasBlocks\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a node has block children.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasBlocks\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"ElementIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element has block children, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hasinlines\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hasinlines\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasInlines\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a node has inline and text children.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasInlines\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"ElementIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element has inline and text children, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hasmark\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hasmark\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasMark\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if mark is active at selection.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasMark\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"key\",type:\"keyof MarksIn<V>\",children:(0,e.jsx)(n.p,{children:\"The mark key to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the mark is active at the current selection, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"haspath\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#haspath\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasPath\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path exists in the editor.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasPath\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the path exists, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hastexts\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hastexts\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasTexts\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a node has text children.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasTexts\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"ElementIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element has text children, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isat\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isat\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isAt\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a location (point/range) is at a specific position.\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`// For ranges:\neditor.api.isAt({ text: true }) // Check if range is in a single text node\neditor.api.isAt({ block: true }) // Check if range is in a single block\neditor.api.isAt({ blocks: true }) // Check if range is across multiple blocks\neditor.api.isAt({ start: true }) // Check if range starts at block start\neditor.api.isAt({ end: true }) // Check if range ends at block end\n\n// For points:\neditor.api.isAt({ word: true }) // Check relative to word boundaries\neditor.api.isAt({ start: true }) // Check if at start\neditor.api.isAt({ end: true }) // Check if at end\n`,children:(0,e.jsxs)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:[(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// For ranges:\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ text: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if range is in a single text node\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ block: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if range is in a single block\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ blocks: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if range is across multiple blocks\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ start: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if range starts at block start\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ end: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if range ends at block end\"})]}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:\" \"}),`\n`,(0,e.jsx)(n.span,{className:\"line\",children:(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// For points:\"})}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ word: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check relative to word boundaries\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ start: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if at start\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isAt\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"({ end: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if at end\"})]})]})})}),`\n`,(0,e.jsxs)(t,{name:\"isAt\",children:[(0,e.jsxs)(r,{type:\"object\",children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to check. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"text\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if range is in a single text node.\"})}),(0,e.jsx)(i,{name:\"block\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if range is in a single block.\"})}),(0,e.jsx)(i,{name:\"blocks\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if range is across multiple blocks.\"})}),(0,e.jsx)(i,{name:\"start\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if at start position.\"})}),(0,e.jsx)(i,{name:\"end\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if at end position.\"})}),(0,e.jsx)(i,{name:\"word\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check relative to word boundaries.\"})})]}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the location matches all specified position criteria, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"iscollapsed\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#iscollapsed\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isCollapsed\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the selection is collapsed (start and end points are the same).\"}),`\n`,(0,e.jsx)(t,{name:\"isCollapsed\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the selection is collapsed, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"isedge\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isedge\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isEdge\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a point is an edge of a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"isEdge\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"point\",type:\"Point\",children:(0,e.jsx)(n.p,{children:\"The point to check.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to check against. Defaults to current selection.\"})})]}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the point is an edge of the location, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"iseditorend\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#iseditorend\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isEditorEnd\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if selection is at editor end.\"}),`\n`,(0,e.jsx)(t,{name:\"isEditorEnd\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the selection is at the editor end, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"isempty\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isempty\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isEmpty\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if an element is empty, accounting for void nodes.\"}),`\n`,(0,e.jsx)(n.div,{\"data-rehype-pretty-code-fragment\":\"\",children:(0,e.jsx)(n.pre,{\"data-language\":\"ts\",\"data-theme\":\"default\",__rawString__:`editor.api.isEmpty() // Check if editor is empty\neditor.api.isEmpty(at) // Check if nodes at location are empty\neditor.api.isEmpty(at, { after: true }) // Check if text after location is empty\neditor.api.isEmpty(at, { block: true }) // Check if block above location is empty\n`,children:(0,e.jsxs)(n.code,{\"data-language\":\"ts\",\"data-theme\":\"default\",children:[(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isEmpty\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"() \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if editor is empty\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isEmpty\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"(at) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if nodes at location are empty\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isEmpty\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"(at, { after: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if text after location is empty\"})]}),`\n`,(0,e.jsxs)(n.span,{className:\"line\",children:[(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"editor.api.\"}),(0,e.jsx)(n.span,{style:{color:\"#B392F0\"},children:\"isEmpty\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\"(at, { block: \"}),(0,e.jsx)(n.span,{style:{color:\"#79B8FF\"},children:\"true\"}),(0,e.jsx)(n.span,{style:{color:\"#E1E4E8\"},children:\" }) \"}),(0,e.jsx)(n.span,{style:{color:\"#6A737D\"},children:\"// Check if block above location is empty\"})]})]})})}),`\n`,(0,e.jsxs)(t,{name:\"isEmpty\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At | null\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to check for emptiness. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorEmptyOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for determining emptiness.\"})})]}),(0,e.jsxs)(r,{type:\"EditorEmptyOptions\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0}),(0,e.jsx)(i,{name:\"after\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if text after selection is empty.\"})}),(0,e.jsx)(i,{name:\"block\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if the block above location is empty.\"})})]}),(0,e.jsx)(a,{type:\"boolean\"})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isend\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isend\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isEnd\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a point is the end point of a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"isEnd\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"point\",type:\"Point\",children:(0,e.jsx)(n.p,{children:\"The point to check.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to check against. Defaults to current selection.\"})})]}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the point is the end point of the location, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isexpanded\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isexpanded\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isExpanded\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the selection is expanded (start and end points are different).\"}),`\n`,(0,e.jsx)(t,{name:\"isExpanded\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the selection is expanded, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"isnormalizing\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isnormalizing\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isNormalizing\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the editor is currently normalizing after each operation.\"}),`\n`,(0,e.jsx)(t,{name:\"isNormalizing\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor is currently normalizing, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"isstart\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isstart\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isStart\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a point is the start point of a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"isStart\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"point\",type:\"Point\",children:(0,e.jsx)(n.p,{children:\"The point to check.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to check against. Defaults to current selection.\"})})]}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the point is the start point of the location, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isselected\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isselected\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isSelected\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a path is selected by the current selection.\"}),`\n`,(0,e.jsxs)(t,{name:\"isSelected\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"target\",type:\"Path | TRange\",children:(0,e.jsx)(n.p,{children:\"The path or range to check.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorIsSelectedOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for checking selection.\"})})]}),(0,e.jsx)(r,{type:\"EditorIsSelectedOptions\",children:(0,e.jsx)(i,{name:\"contains\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Check if selection contains the entire path range.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the path is selected, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"leaf\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#leaf\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"leaf\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the leaf text node at a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"leaf\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",children:(0,e.jsx)(n.p,{children:\"The location to get the leaf from.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorLeafOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for getting the leaf.\"})})]}),(0,e.jsxs)(r,{type:\"EditorLeafOptions\",children:[(0,e.jsx)(i,{name:\"depth\",type:\"number\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The depth to traverse to find the leaf.\"})}),(0,e.jsx)(i,{name:\"edge\",type:\"LeafEdge\",optional:!0,children:(0,e.jsxs)(n.p,{children:[\"Which edge of the location to get the leaf from (\",(0,e.jsx)(n.code,{children:\"'start' | 'end'\"}),\").\"]})})]}),(0,e.jsx)(a,{type:\"NodeEntry<TextIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the leaf text node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"levels\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#levels\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"levels\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Iterate through all levels at a location. This includes all ancestors up to the root editor node.\"}),`\n`,(0,e.jsxs)(t,{name:\"levels\",children:[(0,e.jsxs)(r,{type:\"EditorLevelsOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for matching levels.\"})}),(0,e.jsx)(i,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to traverse in reverse order (bottom-up vs. top-down).\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the traversal.\"})})]}),(0,e.jsx)(a,{type:\"Generator<NodeEntry<NodeIn<V>>, void, undefined>\",children:(0,e.jsx)(n.p,{children:\"A generator that yields tuples of [node, path] for each ancestor level.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"last\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#last\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"last\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the last node at a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"last\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",children:(0,e.jsx)(n.p,{children:\"The location to get the last node from.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorLastOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for getting the last node.\"})})]}),(0,e.jsx)(r,{type:\"EditorLastOptions\",children:(0,e.jsx)(i,{name:\"level\",type:\"number\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Get last node at this level (0-based).\"})})}),(0,e.jsx)(a,{type:\"NodeEntry<DescendantIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the last node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"mark\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#mark\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"mark\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Returns the selection mark value by key.\"}),`\n`,(0,e.jsxs)(t,{name:\"mark\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"key\",type:\"keyof MarksIn<V>\",children:(0,e.jsx)(n.p,{children:\"The mark key.\"})})}),(0,e.jsx)(a,{type:\"MarksIn<V>[K] | null | undefined\",children:(0,e.jsx)(n.p,{children:\"The mark value if it exists, null if not set, or undefined if multiple different values exist.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"marks\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#marks\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"marks\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the marks that would be added to text at the current selection.\"}),`\n`,(0,e.jsx)(t,{name:\"marks\",children:(0,e.jsx)(a,{type:\"MarksIn<V> | null\",children:(0,e.jsx)(n.p,{children:\"The marks at the current selection, or null if there are no marks.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"next\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#next\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"next\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the matching node in the branch of the document after a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"next\",children:[(0,e.jsxs)(r,{type:\"EditorNextOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for matching nodes.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At | Span\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to start searching from. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode for matching nodes.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})}),(0,e.jsx)(i,{name:\"from\",type:\"'after' | 'child'\",optional:!0,children:(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'after'\"}),\": Start from point after current location\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'child'\"}),\": Start from the first child of current path\"]}),`\n`]})})]}),(0,e.jsx)(a,{type:\"NodeEntry<DescendantIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the next matching node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"node\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#node\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"node\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the node at a location or find the first node that matches options.\"}),`\n`,(0,e.jsxs)(t,{name:\"node\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get a node from.\"})}),(0,e.jsx)(i,{name:\"nodeOptions\",type:\"EditorNodeOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for getting a node.\"})})]}),(0,e.jsxs)(r,{type:\"EditorNodeOptions\",children:[(0,e.jsx)(i,{name:\"depth\",type:\"number\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The depth to traverse to find the node.\"})}),(0,e.jsx)(i,{name:\"edge\",type:\"'start' | 'end'\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Which edge of the location to get the node from.\"})})]}),(0,e.jsx)(a,{type:\"NodeEntry<NodeIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the matching node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"nodes\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#nodes\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"nodes\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Iterate through all nodes in the editor that match the given options.\"}),`\n`,(0,e.jsxs)(t,{name:\"nodes\",children:[(0,e.jsxs)(r,{type:\"EditorNodesOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for matching nodes.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At | Span\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Where to start iterating. Defaults to editor selection.\"})}),(0,e.jsx)(i,{name:\"ignoreNonSelectable\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ignore non-selectable nodes during traversal.\"})}),(0,e.jsx)(i,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to traverse in reverse order.\"})}),(0,e.jsx)(i,{name:\"universal\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ensure the operation works universally across all nodes.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'all'\"}),\": Return all matching nodes\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'highest'\"}),\": Return highest-level matching nodes\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'lowest'\"}),\": Return lowest-level matching nodes\"]}),`\n`]})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})})]}),(0,e.jsx)(a,{type:\"Generator<NodeEntry<DescendantIn<V>>, void, undefined>\",children:(0,e.jsx)(n.p,{children:\"A generator that yields tuples of [node, path] for each matching node.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"parent\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#parent\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"parent\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the parent node of a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"parent\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get the parent from.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorParentOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for getting the parent node.\"})})]}),(0,e.jsxs)(r,{type:\"EditorParentOptions\",children:[(0,e.jsx)(i,{name:\"depth\",type:\"number\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Number of levels to traverse up to find the parent.\"})}),(0,e.jsx)(i,{name:\"edge\",type:\"'start' | 'end'\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Which edge of the location to get the parent from.\"})})]}),(0,e.jsx)(a,{type:\"NodeEntry<AncestorIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the parent node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"previous\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#previous\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"previous\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the matching node in the branch of the document before a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"previous\",children:[(0,e.jsxs)(r,{type:\"EditorPreviousOptions<V>\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<V>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for matching nodes.\"})}),(0,e.jsx)(i,{name:\"at\",type:\"At | Span\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to start searching from. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode for matching nodes.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})}),(0,e.jsx)(i,{name:\"sibling\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to get the previous sibling node instead of any previous node.\"})}),(0,e.jsx)(i,{name:\"from\",type:\"'before' | 'parent'\",optional:!0,children:(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'before'\"}),\": Start from point before current location\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'parent'\"}),\": Start from parent of current location\"]}),`\n`]})})]}),(0,e.jsx)(a,{type:\"NodeEntry<DescendantIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the previous matching node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"prop\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#prop\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"prop\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Get a property value from a list of nodes. Returns \",(0,e.jsx)(n.code,{children:\"undefined\"}),\" if the property value is not consistent across all nodes.\"]}),`\n`,(0,e.jsxs)(t,{name:\"prop\",children:[(0,e.jsxs)(r,{type:\"EditorPropOptions<V>\",children:[(0,e.jsx)(i,{name:\"nodes\",type:\"TElement[]\",children:(0,e.jsx)(n.p,{children:\"The list of nodes to get the property value from.\"})}),(0,e.jsx)(i,{name:\"key\",type:\"string\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The property key to get from the nodes.\"})}),(0,e.jsx)(i,{name:\"defaultValue\",type:\"string\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Default value to return if property is not found.\"})}),(0,e.jsx)(i,{name:\"getProp\",type:\"(node: DescendantIn<V>) => any\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Custom function to extract property value from a node.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"'all' | 'block' | 'text'\",optional:!0,children:(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'all'\"}),\": Get property from all nodes\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'block'\"}),\": Get property from the first block node\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'text'\"}),\": Get property from the first text node\"]}),`\n`]})})]}),(0,e.jsx)(a,{type:\"string | undefined\",children:(0,e.jsxs)(n.p,{children:[\"The consistent property value across all nodes, or \",(0,e.jsx)(n.code,{children:\"undefined\"}),\" if values differ.\"]})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"string\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#string\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"string\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the text string content of a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"string\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get text content from. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorStringOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for getting text content.\"})})]}),(0,e.jsx)(r,{type:\"EditorStringOptions\",children:(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include text content from void nodes.\"})})}),(0,e.jsx)(a,{type:\"string\",children:(0,e.jsx)(n.p,{children:\"The text content at the specified location.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"void\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#void\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"void\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Match a void node in the current branch of the editor.\"}),`\n`,(0,e.jsxs)(t,{name:\"void\",children:[(0,e.jsxs)(r,{type:\"EditorVoidOptions\",children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to search from. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode for matching nodes.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})})]}),(0,e.jsx)(a,{type:\"NodeEntry<ElementIn<V>> | undefined\",children:(0,e.jsx)(n.p,{children:\"A tuple containing the void node and its path, or undefined if not found.\"})})]}),`\n`,(0,e.jsxs)(n.h2,{id:\"location\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#location\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Location\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"findpath\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#findpath\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"findPath\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find the path of a Plate node in the editor.\"}),`\n`,(0,e.jsxs)(t,{name:\"findPath\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"node\",type:\"TNode\",children:(0,e.jsx)(n.p,{children:\"The node to find the path for in the editor tree.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorFindPathOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for finding the node's path.\"})})]}),(0,e.jsxs)(r,{type:\"EditorFindPathOptions\",children:[(0,e.jsx)(i,{name:\"...options\",type:\"QueryOptions<Value>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Common query options for finding nodes.\"})}),(0,e.jsx)(i,{name:\"ignoreNonSelectable\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ignore non-selectable nodes during traversal.\"})}),(0,e.jsx)(i,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to traverse in reverse order.\"})}),(0,e.jsx)(i,{name:\"universal\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to ensure the operation works universally across all nodes.\"})}),(0,e.jsx)(i,{name:\"mode\",type:\"QueryMode\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Query mode for finding nodes.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include void nodes in the search.\"})})]}),(0,e.jsx)(a,{type:\"Path | undefined\",children:(0,e.jsx)(n.p,{children:\"The path of the node if found, undefined otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"path\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#path\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"path\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the path of a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"path\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get the path from. Defaults to current selection.\"})})}),(0,e.jsx)(a,{type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path of the location.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"point\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#point\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"point\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Get the \",(0,e.jsx)(n.code,{children:\"start\"}),\" or \",(0,e.jsx)(n.code,{children:\"end\"}),\" (default is \",(0,e.jsx)(n.code,{children:\"start\"}),\") point of a location.\"]}),`\n`,(0,e.jsxs)(t,{name:\"point\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get the point from. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorPointOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for getting the point.\"})})]}),(0,e.jsx)(r,{type:\"EditorPointOptions\",children:(0,e.jsx)(i,{name:\"edge\",type:\"'start' | 'end'\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Which edge of the location to get the point from.\"})})}),(0,e.jsx)(a,{type:\"Point\",children:(0,e.jsx)(n.p,{children:\"The point at the specified location and edge.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"positions\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#positions\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"positions\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Iterate through all possible point positions in the document.\"}),`\n`,(0,e.jsxs)(t,{name:\"positions\",children:[(0,e.jsxs)(r,{type:\"EditorPositionsOptions\",children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Where to start iterating. Defaults to editor selection.\"})}),(0,e.jsx)(i,{name:\"unit\",type:\"TextUnitAdjustment\",optional:!0,children:(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'offset'\"}),\": Moves to the next offset Point\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'character'\"}),\": Moves to the next character\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'word'\"}),\": Moves to the position after the next word\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'line'\"}),\" | 'block': Moves between block boundaries\"]}),`\n`]})}),(0,e.jsx)(i,{name:\"reverse\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"When true returns positions in reverse order.\"})}),(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to include positions inside void nodes.\"})}),(0,e.jsx)(i,{name:\"ignoreNonSelectable\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to skip positions in non-selectable nodes.\"})})]}),(0,e.jsx)(a,{type:\"Generator<Point, void, undefined>\",children:(0,e.jsx)(n.p,{children:\"A generator that yields each valid point position in the document.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"nodesrange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#nodesrange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"nodesRange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Returns the range spanning the given node entries.\"}),`\n`,(0,e.jsxs)(t,{name:\"nodesRange\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"nodes\",type:\"NodeEntry[]\",children:(0,e.jsx)(n.p,{children:\"The node entries to get the range for.\"})})}),(0,e.jsx)(a,{type:\"TRange | undefined\",children:(0,e.jsx)(n.p,{children:\"The range spanning the nodes, or undefined if no valid range can be created.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"range\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#range\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"range\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Create a range between two locations.\"}),`\n`,(0,e.jsxs)(t,{name:\"range\",children:[(0,e.jsxs)(r,{type:\"EditorRangeOptions\",children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to create the range at. Defaults to current selection.\"})}),(0,e.jsx)(i,{name:\"focus\",type:\"Point\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The focus (end) point of the range.\"})}),(0,e.jsx)(i,{name:\"anchor\",type:\"Point\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The anchor (start) point of the range.\"})})]}),(0,e.jsx)(a,{type:\"TRange\",children:(0,e.jsx)(n.p,{children:\"A new range between the specified points.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"start\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#start\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"start\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the start point of a location.\"}),`\n`,(0,e.jsxs)(t,{name:\"start\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"at\",type:\"At\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The location to get the start point from.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorStartOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for getting the start point.\"})})]}),(0,e.jsx)(r,{type:\"EditorStartOptions\",children:(0,e.jsx)(i,{name:\"next\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Get the start point of the next node instead of the current one.\"})})}),(0,e.jsx)(a,{type:\"Point\",children:(0,e.jsx)(n.p,{children:\"The start point of the location.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"unhangrange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#unhangrange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"unhangRange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Convert a range into a non-hanging one.\"}),`\n`,(0,e.jsxs)(n.p,{children:[`A \"hanging\" range is one created by the browser's \"triple-click\" selection behavior. When triple-clicking a block, the browser selects from the start of that block to the start of the `,(0,e.jsx)(n.em,{children:\"next\"}),' block. The range thus \"hangs over\" into the next block. If ',(0,e.jsx)(n.code,{children:\"unhangRange\"}),\" is given such a range, it moves the end backwards until it's in a non-empty text node that precedes the hanging block.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Note that \",(0,e.jsx)(n.code,{children:\"unhangRange\"}),\" is designed for the specific purpose of fixing triple-clicked blocks, and therefore currently has a number of caveats:\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:'It does not modify the start of the range; only the end. For example, it does not \"unhang\" a selection that starts at the end of a previous block.'}),`\n`,(0,e.jsx)(n.li,{children:\"It only does anything if the start block is fully selected. For example, it does not handle ranges created by double-clicking the end of a paragraph (which browsers treat by selecting from the end of that paragraph to the start of the next).\"}),`\n`]}),`\n`,(0,e.jsxs)(t,{name:\"unhangRange\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"range\",type:\"TRange\",children:(0,e.jsx)(n.p,{children:\"The range to unhang.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorUnhangRangeOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for un-hanging the range.\"})})]}),(0,e.jsx)(r,{type:\"EditorUnhangRangeOptions\",children:(0,e.jsx)(i,{name:\"voids\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Allow placing the end of the selection in a void node.\"})})}),(0,e.jsx)(a,{type:\"TRange\",children:(0,e.jsx)(n.p,{children:\"A new range with the end point moved backwards if it was hanging.\"})})]}),`\n`,(0,e.jsxs)(n.h2,{id:\"element\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#element\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Element\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"elementreadonly\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#elementreadonly\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"elementReadOnly\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if an element is read-only.\"}),`\n`,(0,e.jsxs)(t,{name:\"elementReadOnly\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"ElementIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check for read-only status.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element is read-only, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isblock\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isblock\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isBlock\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Check if a value is a block \",(0,e.jsx)(n.code,{children:\"Element\"}),\" object.\"]}),`\n`,(0,e.jsxs)(t,{name:\"isBlock\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"value\",type:\"any\",children:(0,e.jsx)(n.p,{children:\"The value to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the value is a block element, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isinline\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isinline\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isInline\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Check if a value is an inline \",(0,e.jsx)(n.code,{children:\"Element\"}),\" object.\"]}),`\n`,(0,e.jsxs)(t,{name:\"isInline\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"DescendantIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element is inline, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isselectable\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isselectable\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isSelectable\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Check if a value is a selectable \",(0,e.jsx)(n.code,{children:\"Element\"}),\" object.\"]}),`\n`,(0,e.jsxs)(t,{name:\"isSelectable\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"ElementIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element is selectable, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"isvoid\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isvoid\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isVoid\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if an element is void.\"}),`\n`,(0,e.jsxs)(t,{name:\"isVoid\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"ElementIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check for void status.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element is void, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"markablevoid\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#markablevoid\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"markableVoid\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if an element is a markable void element.\"}),`\n`,(0,e.jsxs)(t,{name:\"markableVoid\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"element\",type:\"ElementIn<V>\",children:(0,e.jsx)(n.p,{children:\"The element to check for markable void status.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the element is a markable void element, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h2,{id:\"ref\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#ref\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Ref\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"pathref\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#pathref\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"pathRef\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Create a mutable ref for a \",(0,e.jsx)(n.code,{children:\"Path\"}),\".\"]}),`\n`,(0,e.jsxs)(t,{name:\"pathRef\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"path\",type:\"Path\",children:(0,e.jsx)(n.p,{children:\"The path to reference.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorPathRefOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for the path reference.\"})})]}),(0,e.jsx)(r,{type:\"EditorPathRefOptions\",children:(0,e.jsxs)(i,{name:\"affinity\",type:\"TextDirection | null\",optional:!0,children:[(0,e.jsx)(n.p,{children:\"The direction to resolve the ref when ambiguous:\"}),(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'forward'\"}),\": Resolve to the next valid position\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'backward'\"}),\": Resolve to the previous valid position\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"null\"}),\": Do not resolve to any position\"]}),`\n`]})]})}),(0,e.jsx)(a,{type:\"PathRef\",children:(0,e.jsx)(n.p,{children:\"A mutable reference that updates its path as operations are applied to the editor.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"pathrefs\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#pathrefs\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"pathRefs\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the set of currently tracked path refs of the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"pathRefs\",children:(0,e.jsx)(a,{type:\"Set<PathRef>\",children:(0,e.jsx)(n.p,{children:\"The set of tracked path refs.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"pointref\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#pointref\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"pointRef\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Create a mutable ref for a \",(0,e.jsx)(n.code,{children:\"Point\"}),\".\"]}),`\n`,(0,e.jsxs)(t,{name:\"pointRef\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"point\",type:\"Point\",children:(0,e.jsx)(n.p,{children:\"The point to reference.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorPointRefOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for the point reference.\"})})]}),(0,e.jsx)(r,{type:\"EditorPointRefOptions\",children:(0,e.jsxs)(i,{name:\"affinity\",type:\"TextDirection | null\",optional:!0,children:[(0,e.jsx)(n.p,{children:\"The direction to resolve the ref when ambiguous:\"}),(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'forward'\"}),\": Resolve to the next valid position\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'backward'\"}),\": Resolve to the previous valid position\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"null\"}),\": Do not resolve to any position\"]}),`\n`]})]})}),(0,e.jsx)(a,{type:\"PointRef\",children:(0,e.jsx)(n.p,{children:\"A mutable reference that updates its point as operations are applied to the editor.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"pointrefs\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#pointrefs\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"pointRefs\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the set of currently tracked point refs of the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"pointRefs\",children:(0,e.jsx)(a,{type:\"Set<PointRef>\",children:(0,e.jsx)(n.p,{children:\"The set of tracked point refs.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"rangeref\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#rangeref\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"rangeRef\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Create a mutable ref for a \",(0,e.jsx)(n.code,{children:\"Range\"}),\".\"]}),`\n`,(0,e.jsxs)(t,{name:\"rangeRef\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"range\",type:\"TRange\",children:(0,e.jsx)(n.p,{children:\"The range to reference.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"EditorRangeRefOptions\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for the range reference.\"})})]}),(0,e.jsx)(r,{type:\"EditorRangeRefOptions\",children:(0,e.jsxs)(i,{name:\"affinity\",type:\"RangeDirection | null\",optional:!0,children:[(0,e.jsx)(n.p,{children:\"The direction to resolve the ref when ambiguous:\"}),(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'forward'\"}),\": Resolve both points forward\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'backward'\"}),\": Resolve both points backward\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'outward'\"}),\": Resolve start backward and end forward\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"'inward'\"}),\": Resolve start forward and end backward\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"null\"}),\": Do not resolve to any position\"]}),`\n`]})]})}),(0,e.jsx)(a,{type:\"RangeRef\",children:(0,e.jsx)(n.p,{children:\"A mutable reference that updates its range as operations are applied to the editor.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"rangerefs\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#rangerefs\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"rangeRefs\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the set of currently tracked range refs of the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"rangeRefs\",children:(0,e.jsx)(a,{type:\"Set<RangeRef>\",children:(0,e.jsx)(n.p,{children:\"The set of tracked range refs.\"})})}),`\n`,(0,e.jsxs)(n.h2,{id:\"dom\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#dom\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"DOM\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"finddocumentorshadowroot\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#finddocumentorshadowroot\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"findDocumentOrShadowRoot\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find the document or shadow root from the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"findDocumentOrShadowRoot\",children:(0,e.jsx)(a,{type:\"Document | ShadowRoot\",children:(0,e.jsx)(n.p,{children:\"The document or shadow root containing the editor.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"findeventrange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#findeventrange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"findEventRange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the target range from a DOM event.\"}),`\n`,(0,e.jsxs)(t,{name:\"findEventRange\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"event\",type:\"Event\",children:(0,e.jsx)(n.p,{children:\"The DOM event to get the range from.\"})})}),(0,e.jsx)(a,{type:\"TRange | null\",children:(0,e.jsx)(n.p,{children:\"The range at the event target, or null if no valid range found.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"findkey\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#findkey\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"findKey\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Find a key for a Plate node. Returns an instance of \",(0,e.jsx)(n.code,{children:\"Key\"}),\" which looks like \",(0,e.jsx)(n.code,{children:\"{ id: string }\"}),\".\"]}),`\n`,(0,e.jsxs)(t,{name:\"findKey\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"node\",type:\"TNode\",children:(0,e.jsx)(n.p,{children:\"The node to find the key for.\"})})}),(0,e.jsx)(a,{type:\"Key\",children:(0,e.jsx)(n.p,{children:\"The key associated with the node.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"getwindow\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#getwindow\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"getWindow\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the window object from the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"getWindow\",children:(0,e.jsx)(a,{type:\"Window\",children:(0,e.jsx)(n.p,{children:\"The window object associated with the editor.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"hasdomnode\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hasdomnode\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasDOMNode\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a DOM node is within the editor.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasDOMNode\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"target\",type:\"Node\",children:(0,e.jsx)(n.p,{children:\"The DOM node to check.\"})}),(0,e.jsx)(i,{name:\"options\",type:\"object\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Options for checking the DOM node.\"})})]}),(0,e.jsx)(r,{type:\"object\",children:(0,e.jsx)(i,{name:\"editable\",type:\"boolean\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Whether to check if the node is in an editable element.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the DOM node is within the editor, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"haseditabletarget\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#haseditabletarget\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasEditableTarget\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a DOM target is editable.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasEditableTarget\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"target\",type:\"EventTarget | null\",children:(0,e.jsx)(n.p,{children:\"The DOM target to check.\"})})}),(0,e.jsx)(a,{type:\"target is Node\",children:(0,e.jsx)(n.p,{children:\"True if the target is editable, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hasrange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hasrange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasRange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the editor has a range.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasRange\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"range\",type:\"TRange\",children:(0,e.jsx)(n.p,{children:\"The range to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor has the specified range, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hasselectabletarget\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hasselectabletarget\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasSelectableTarget\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a DOM target is selectable.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasSelectableTarget\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"target\",type:\"EventTarget | null\",children:(0,e.jsx)(n.p,{children:\"The DOM target to check.\"})})}),(0,e.jsx)(a,{type:\"target is Node\",children:(0,e.jsx)(n.p,{children:\"True if the target is selectable, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"hastarget\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#hastarget\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"hasTarget\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if a DOM target exists.\"}),`\n`,(0,e.jsxs)(t,{name:\"hasTarget\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"target\",type:\"EventTarget | null\",children:(0,e.jsx)(n.p,{children:\"The DOM target to check.\"})})}),(0,e.jsx)(a,{type:\"target is Node\",children:(0,e.jsx)(n.p,{children:\"True if the target exists, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"iscomposing\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#iscomposing\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isComposing\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the user is currently composing inside the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"isComposing\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the user is currently composing text, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"isfocused\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isfocused\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isFocused\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the editor is focused.\"}),`\n`,(0,e.jsx)(t,{name:\"isFocused\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor has focus, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"isreadonly\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#isreadonly\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isReadOnly\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Check if the editor is in read-only mode.\"}),`\n`,(0,e.jsx)(t,{name:\"isReadOnly\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor is read-only, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"todomnode\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#todomnode\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"toDOMNode\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find the native DOM element from a Plate node.\"}),`\n`,(0,e.jsxs)(t,{name:\"toDOMNode\",children:[(0,e.jsx)(r,{type:\"TNode\",children:(0,e.jsx)(i,{name:\"node\",type:\"TNode\",children:(0,e.jsx)(n.p,{children:\"The Plate node to convert to a DOM element.\"})})}),(0,e.jsx)(a,{type:\"HTMLElement\",children:(0,e.jsx)(n.p,{children:\"The corresponding DOM element for the Plate node.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"todompoint\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#todompoint\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"toDOMPoint\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find a native DOM selection point from a Plate point.\"}),`\n`,(0,e.jsxs)(t,{name:\"toDOMPoint\",children:[(0,e.jsx)(r,{type:\"Point\",children:(0,e.jsx)(i,{name:\"point\",type:\"Point\",children:(0,e.jsx)(n.p,{children:\"The Plate point to convert to a DOM point.\"})})}),(0,e.jsx)(a,{type:\"DOMPoint\",children:(0,e.jsx)(n.p,{children:\"A tuple of [node, offset] representing the DOM point.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"todomrange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#todomrange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"toDOMRange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find a native DOM range from a Plate range.\"}),`\n`,(0,e.jsxs)(t,{name:\"toDOMRange\",children:[(0,e.jsx)(r,{type:\"TRange\",children:(0,e.jsx)(i,{name:\"range\",type:\"TRange\",children:(0,e.jsx)(n.p,{children:\"The Plate range to convert to a DOM range.\"})})}),(0,e.jsx)(a,{type:\"DOMRange\",children:(0,e.jsx)(n.p,{children:\"The corresponding DOM range for the Plate range.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"toslatenode\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#toslatenode\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"toSlateNode\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find a Plate node from a native DOM element.\"}),`\n`,(0,e.jsxs)(t,{name:\"toSlateNode\",children:[(0,e.jsx)(r,{type:\"DOMNode\",children:(0,e.jsx)(i,{name:\"domNode\",type:\"DOMNode\",children:(0,e.jsx)(n.p,{children:\"The DOM node to convert to a Plate node.\"})})}),(0,e.jsx)(a,{type:\"TNode | undefined\",children:(0,e.jsx)(n.p,{children:\"The corresponding Plate node if found, undefined otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"toslatepoint\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#toslatepoint\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"toSlatePoint\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find a Plate point from a DOM selection point.\"}),`\n`,(0,e.jsxs)(t,{name:\"toSlatePoint\",children:[(0,e.jsx)(r,{type:\"DOMPoint\",children:(0,e.jsx)(i,{name:\"domPoint\",type:\"DOMPoint\",children:(0,e.jsx)(n.p,{children:\"The DOM point to convert to a Plate point.\"})})}),(0,e.jsx)(a,{type:\"Point | undefined\",children:(0,e.jsx)(n.p,{children:\"The corresponding Plate point if found, undefined otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"toslaterange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#toslaterange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"toSlateRange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Find a Plate range from a DOM range.\"}),`\n`,(0,e.jsxs)(t,{name:\"toSlateRange\",children:[(0,e.jsx)(r,{type:\"DOMRange\",children:(0,e.jsx)(i,{name:\"domRange\",type:\"DOMRange\",children:(0,e.jsx)(n.p,{children:\"The DOM range to convert to a Plate range.\"})})}),(0,e.jsx)(a,{type:\"TRange | undefined\",children:(0,e.jsx)(n.p,{children:\"The corresponding Plate range if found, undefined otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h2,{id:\"callback\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#callback\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Callback\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"onchange\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#onchange\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"onChange\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Called when there is a change in the editor.\"}),`\n`,(0,e.jsx)(t,{name:\"onChange\",children:(0,e.jsx)(r,{type:\"object\",children:(0,e.jsx)(i,{name:\"operation\",type:\"Operation\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The operation that triggered the change.\"})})})}),`\n`,(0,e.jsxs)(n.h2,{id:\"core\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#core\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Core\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"getdirtypaths\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#getdirtypaths\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"getDirtyPaths\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the paths that need to be normalized after an operation.\"}),`\n`,(0,e.jsxs)(t,{name:\"getDirtyPaths\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"operation\",type:\"Operation<N extends DescendantIn<V>>\",children:(0,e.jsx)(n.p,{children:\"The operation that triggered normalization.\"})})}),(0,e.jsx)(a,{type:\"Path[]\",children:(0,e.jsx)(n.p,{children:\"An array of paths that need to be normalized after the operation.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"shouldnormalizenode\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#shouldnormalizenode\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"shouldNormalizeNode\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Override this method to prevent normalizing a specific node. Defaults to returning \",(0,e.jsx)(n.code,{children:\"true\"}),\".\"]}),`\n`,(0,e.jsxs)(t,{name:\"shouldNormalizeNode\",children:[(0,e.jsx)(o,{children:(0,e.jsx)(i,{name:\"entry\",type:\"NodeEntry\",children:(0,e.jsx)(n.p,{children:\"The node entry (node and path) to check.\"})})}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the node should be normalized, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"setnormalizing\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#setnormalizing\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"setNormalizing\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Manually control the editor's normalizing state.\"}),`\n`,(0,e.jsx)(t,{name:\"setNormalizing\",children:(0,e.jsx)(r,{type:\"boolean\",children:(0,e.jsx)(i,{name:\"isNormalizing\",type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"Whether the editor should normalize after each operation.\"})})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"shouldnormalize\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#shouldnormalize\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"shouldNormalize\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Controls whether the editor should normalize after an operation. Override this method to prevent normalizing in certain situations.\"}),`\n`,(0,e.jsxs)(t,{name:\"shouldNormalize\",children:[(0,e.jsxs)(r,{type:\"object\",children:[(0,e.jsx)(i,{name:\"dirtyPaths\",type:\"Path[]\",children:(0,e.jsx)(n.p,{children:\"The paths that need to be normalized.\"})}),(0,e.jsx)(i,{name:\"initialDirtyPathsLength\",type:\"number\",children:(0,e.jsx)(n.p,{children:\"The initial number of dirty paths before normalization started.\"})}),(0,e.jsx)(i,{name:\"iteration\",type:\"number\",children:(0,e.jsx)(n.p,{children:\"The current normalization iteration count.\"})}),(0,e.jsx)(i,{name:\"operation\",type:\"Operation\",optional:!0,children:(0,e.jsx)(n.p,{children:\"The operation that triggered the normalization.\"})})]}),(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor should normalize, false otherwise.\"})})]}),`\n`,(0,e.jsxs)(n.h2,{id:\"history\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#history\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"History\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"ismerging\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#ismerging\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isMerging\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the merge flag's current value.\"}),`\n`,(0,e.jsx)(t,{name:\"isMerging\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor is currently merging operations, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"issaving\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#issaving\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isSaving\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the saving flag's current value.\"}),`\n`,(0,e.jsx)(t,{name:\"isSaving\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor is currently saving, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h3,{id:\"issplittingonce\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#issplittingonce\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"isSplittingOnce\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Get the splitting flag's current value.\"}),`\n`,(0,e.jsx)(t,{name:\"isSplittingOnce\",children:(0,e.jsx)(a,{type:\"boolean\",children:(0,e.jsx)(n.p,{children:\"True if the editor is currently performing a single split operation, false otherwise.\"})})}),`\n`,(0,e.jsxs)(n.h2,{id:\"utils\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#utils\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Utils\"]}),`\n`,(0,e.jsxs)(n.h3,{id:\"createblock\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#createblock\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"create.block\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Default block factory for creating new block elements.\"}),`\n`,(0,e.jsxs)(t,{name:\"create.block\",children:[(0,e.jsxs)(o,{children:[(0,e.jsx)(i,{name:\"node\",type:\"Partial<TElement>\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Partial element properties to merge into the new block.\"})}),(0,e.jsx)(i,{name:\"path\",type:\"Path\",optional:!0,children:(0,e.jsx)(n.p,{children:\"Path for the new block.\"})})]}),(0,e.jsx)(a,{type:\"TElement\",children:(0,e.jsx)(n.p,{children:\"A new block element.\"})})]}),`\n`,(0,e.jsxs)(n.h3,{id:\"createvalue\",children:[(0,e.jsx)(n.a,{\"aria-label\":\"Link to section\",className:\"subheading-anchor group/subheading\",\"data-empty\":\"true\",href:\"#createvalue\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),(0,e.jsx)(n.code,{children:\"create.value\"})]}),`\n`,(0,e.jsx)(n.p,{children:\"Default value factory for creating new editor values.\"}),`\n`,(0,e.jsx)(t,{name:\"create.value\",children:(0,e.jsx)(a,{type:\"Value\",children:(0,e.jsx)(n.p,{children:\"A new editor value.\"})})})]})}function m(l={}){let{wrapper:n}=l.components||{};return n?(0,e.jsx)(n,{...l,children:(0,e.jsx)(u,{...l})}):u(l)}function c(l,n){throw new Error(\"Expected \"+(n?\"component\":\"object\")+\" `\"+l+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return T(F);})();\n;return Component;"
  },
  "_id": "docs/api/slate/editor-api.mdx",
  "_raw": {
    "sourceFilePath": "docs/api/slate/editor-api.mdx",
    "sourceFileName": "editor-api.mdx",
    "sourceFileDir": "docs/api/slate",
    "contentType": "mdx",
    "flattenedPath": "docs/api/slate/editor-api"
  },
  "type": "Doc",
  "slug": "/docs/docs/api/slate/editor-api",
  "slugAsParams": "docs/api/slate/editor-api"
}