# Plate Testing Patterns with Bun

## Overview

Bun's test runner for Plate monorepo. **Critical**: JSX pragma must be first line. Test globals (`describe`, `it`, `expect`, `mock`, `spyOn`, etc.) are global via `tooling/config/global.d.ts` - no imports needed. Use `toMatchObject()` for arrays, `toEqual()` for exact matching. **`mock.module()` is process-global** - use `spyOn()` instead.

**AI Agent Integration**: All test scripts include `CLAUDECODE=1` to enable quieter output - only test failures are shown in detail, passing tests are hidden to reduce context noise.

## When to Use

- Writing tests for Slate transforms, editor operations, plugins
- React hook tests with state changes
- Test failures: cross-file contamination, "Hook timed out", flaky tests
- JSX pragma errors, type mismatches in assertions

## Quick Reference

| Pattern                  | Use Case                 | Example                                |
| ------------------------ | ------------------------ | -------------------------------------- |
| `/** @jsx jsx */` first  | **Slate hyperscript**    | Must be line 1, before all imports     |
| `toMatchObject(array)`   | **Array partial match**  | Checks properties exist, allows extras |
| `toEqual()`              | **Exact match**          | Validates complete structure           |
| `expect(val as any)`     | **Type mismatch**        | Cast actual value, not expected        |
| `mock()` not `jest.fn()` | **Create mock function** | Bun test API                           |
| `spyOn()` + `afterEach`  | **Mock with cleanup**    | Always `spy.mockRestore()`             |
| `renderHook()` + `act()` | **Test hooks**           | Wrap state changes in `act()`          |
| `void act()`             | **Prevent warnings**     | Use with sync click/change events      |
| `createWrapper()`        | **Reusable context**     | Custom wrapper for hook tests          |
| `createEditor()`         | **Slate tests**          | For pure Slate operations              |
| `createPlateEditor()`    | **Plugin tests**         | For React components with plugins      |

## Core Patterns

### JSX Pragma (CRITICAL)

```typescript
/** @jsx jsx */

import { jsx } from "@platejs/test-utils";

jsx; // Prevents removal

// ❌ WRONG - imports before pragma
import { jsx } from "@platejs/test-utils";
/** @jsx jsx */ // Too late!

// Note: describe, it, expect, mock, spyOn are global via tooling/config/global.d.ts
// No test imports needed
```

### Editor Creation

```typescript
// Slate operations - use createEditor
const editor = createEditor();
editor.children = initialValue;
editor.tf.wrapNodes({ type: "blockquote" }, { at: [0, 0] });

// Plugin tests - use createPlateEditor
const editor = createPlateEditor({
  plugins: [MyPlugin],
});
expect(editor.api.testMethod()).toBe("result");
```

### Transform Testing

```typescript
const editor = createEditor();
editor.children = [
  {
    children: [{ text: "test" }],
    type: "paragraph",
  },
];

editor.tf.wrapNodes({ children: [], type: "blockquote" }, { at: [0, 0] });

expect(editor.children).toEqual(expectedValue);
```

### Matcher Selection

```typescript
// ✅ Array partial matching
expect(children).toMatchObject([{ text: "one" }, { text: "two" }]);

// ✅ Exact matching
expect(editor.children).toEqual([{ children: [{ text: "" }], type: "p" }]);

// ✅ Cast actual value for type mismatches
const [node] = NodeApi.firstChild(editor, [0]) ?? [];
expect(node as any).toEqual({ text: "one" });

// ❌ Don't cast expected value
expect(children).toEqual([{ text: "one" }] as any);

// ❌ Don't use toMatchObject() for single objects (won't catch extra props)
expect(node).toMatchObject({ text: "one" });
```

### Mock Usage (Bun)

```typescript
// Replace jest.fn() with mock()
const mockOnChange = mock();

// Spy pattern with cleanup
describe("MyTest", () => {
  let spy: ReturnType<typeof spyOn>;

  beforeEach(async () => {
    const module = await import("./module");
    spy = spyOn(module, "function").mockImplementation(mock());
  });

  afterEach(() => {
    spy?.mockRestore(); // CRITICAL
  });
});
```

### Avoiding Cross-File Contamination

**Problem**: Bun's `mock.module()` is process-global. If `fileA.spec.ts` uses `mock.module('@/lib/api')`, it contaminates `fileB.spec.ts` that imports the real `@/lib/api`.

**Solution**: Use `spyOn()` instead of `mock.module()` for shared dependencies.

#### ❌ WRONG - Causes Cross-Contamination

```typescript
// hooks/useUserPosts.spec.ts

// This globally mocks the module for ALL test files
mock.module("@/lib/services/api/postsApi", () => ({
  fetchPosts: mock(),
  fetchPostsCounts: mock(),
}));

describe("useUserPosts", () => {
  // Tests here contaminate postsApi.spec.ts
});
```

**Result**: `postsApi.spec.ts` fails with "Expected to be called but it was not called" because the mock from `useUserPosts.spec.ts` is still active.

#### ✅ CORRECT - File-Scoped Mocking

```typescript
// hooks/useUserPosts.spec.ts
import * as postsApiModule from "@/lib/services/api/postsApi";

describe("useUserPosts", () => {
  let mockFetchPosts: ReturnType<typeof mock>;
  let mockFetchPostsCounts: ReturnType<typeof mock>;
  let fetchPostsSpy: ReturnType<typeof spyOn>;
  let fetchPostsCountsSpy: ReturnType<typeof spyOn>;

  beforeEach(() => {
    // Create fresh mocks
    mockFetchPosts = mock();
    mockFetchPostsCounts = mock();

    // Spy on the actual module functions
    fetchPostsSpy = spyOn(postsApiModule, "fetchPosts").mockImplementation(
      mockFetchPosts
    );

    fetchPostsCountsSpy = spyOn(
      postsApiModule,
      "fetchPostsCounts"
    ).mockImplementation(mockFetchPostsCounts);

    // Set defaults
    mockFetchPosts.mockResolvedValue(mockPostsResponse);
    mockFetchPostsCounts.mockResolvedValue(mockStatsResponse);
  });

  afterEach(() => {
    // CRITICAL: Restore spies to clean state
    fetchPostsSpy.mockRestore();
    fetchPostsCountsSpy.mockRestore();
  });

  it("fetches posts successfully", async () => {
    const { result } = renderHook(() =>
      useUserPosts({ userId, organizationId })
    );

    await act(async () => {
      await result.current.fetchPosts({ page: 0, status: "published" });
    });

    expect(mockFetchPosts).toHaveBeenCalledWith({
      userId,
      organizationId,
      page: 0,
      pageSize: 20,
      status: "published",
    });
  });
});
```

**Key differences**:

1. Import module as namespace: `import * as apiModule from './api'`
2. Create spies in `beforeEach`: `spyOn(apiModule, 'function')`
3. Always `mockRestore()` in `afterEach`
4. Use mock variables in assertions: `expect(mockFn)` not `expect(apiModule.fn)`

### Testing React Hooks

Use `renderHook()` from `@testing-library/react` and wrap state changes in `act()`:

```typescript
import { act, renderHook } from "@testing-library/react";

it("updates state correctly", async () => {
  const { result } = renderHook(() => useCustomHook());

  // Wrap async state changes in act()
  await act(async () => {
    await result.current.fetchData();
  });

  expect(result.current.data).toEqual(expectedData);
  expect(result.current.loading).toBe(false);
});

// Use void to prevent unused promise warnings
void act(() => getByText("button").click());
```

**Custom wrapper pattern** for context providers:

```typescript
const createWrapper =
  (props) =>
  ({ children }: any) =>
    <Provider {...props}>{children}</Provider>;

const wrapper = createWrapper({ value: "test" });
const { result } = renderHook(() => useCustomHook(), { wrapper });
```

### Testing Async Operations in Hooks

```typescript
it("handles async errors", async () => {
  mockFetch.mockRejectedValue(new Error("Network error"));

  await act(async () => {
    try {
      await result.current.fetchData();
    } catch (error) {
      expect(error).toEqual(new Error("Failed to load data"));
    }
  });

  expect(result.current.error).toBe("Failed to load data");
});
```

### Mocking Dependencies in Hook Tests

```typescript
it("mocks API dependency in hook", async () => {
  // Import module as namespace
  import * as api from "@/lib/api";

  let mockFetchData: ReturnType<typeof mock>;
  let fetchDataSpy: ReturnType<typeof spyOn>;

  beforeEach(() => {
    mockFetchData = mock();
    fetchDataSpy = spyOn(api, "fetchData").mockImplementation(mockFetchData);
    mockFetchData.mockResolvedValue({ data: "test" });
  });

  afterEach(() => {
    fetchDataSpy.mockRestore();
  });

  const { result } = renderHook(() => useCustomHook());

  await act(async () => {
    await result.current.loadData();
  });

  expect(mockFetchData).toHaveBeenCalled();
  expect(result.current.data).toEqual({ data: "test" });
});
```

## Environment Setup

### Configuration (bunfig.toml)

```toml
[test]
# Preload scripts execute BEFORE any test file
# Order matters: happydom MUST come first for document.body
preload = ["./scripts/test-setup.ts"]

# Coverage exclusions
coveragePathIgnorePatterns = [
  "node_modules/**",
  "**/*.d.ts",
]
```

### Preload Script

#### scripts/test-setup.ts

```typescript
import { GlobalRegistrator } from "@happy-dom/global-registrator";
import { afterEach, expect } from "bun:test";
import * as matchers from "@testing-library/jest-dom/matchers";
import { cleanup } from "@testing-library/react";

// Register DOM globals synchronously
GlobalRegistrator.register();

// Ensure document.body exists
if (global.document && !global.document.body) {
  const body = global.document.createElement("body");
  global.document.documentElement.appendChild(body);
}

// Extend Bun's expect with Testing Library matchers
expect.extend(matchers);

// Cleanup after each test
afterEach(() => {
  cleanup();
});
```

### Running Tests

```bash
# Run all tests
bun test

# Run specific test file
bun test src/lib/hooks/useUserPosts.spec.ts

# Watch mode
bun test --watch

# Coverage
bun test --coverage

# Bail on first failure
bun test --bail
```

### AI Agent Integration

Bun's test runner supports AI-friendly output via the `CLAUDECODE=1` environment variable. This is automatically included in all Plate test scripts to reduce context noise for AI coding assistants.

**Behavior with `CLAUDECODE=1`**:

- Only test failures are displayed in detail
- Passing, skipped, and todo test indicators are hidden
- Summary statistics remain intact
- Improves readability and reduces output verbosity

**Manual usage**:

```bash
# Already included in package.json scripts
CLAUDECODE=1 bun test
```

This feature is enabled by default in all Plate test commands (`yarn test`, `yarn p:test`, etc.).

## Common Mistakes

| Mistake                              | Problem                      | Fix                                  |
| ------------------------------------ | ---------------------------- | ------------------------------------ |
| Imports before `/** @jsx jsx */`     | JSX transform fails          | Pragma must be line 1                |
| `toMatchObject()` for single objects | Won't catch extra properties | Use `toEqual()` or cast actual value |
| Casting expected value `as any`      | Hides type mismatches        | Cast actual value instead            |
| Using `mock.module()`                | Cross-file contamination     | Use `spyOn()` + `afterEach` cleanup  |
| Forgetting `spy.mockRestore()`       | Spies persist across tests   | Always restore in `afterEach`        |
| `jest.fn()` / `jest.Mock`            | Wrong framework              | Use `mock()` from `bun:test`         |
| Forgetting `act()` around state      | React warnings, flaky tests  | Wrap state changes in `act()`        |

## Debugging Test Failures

### Test passes alone, fails in suite

**Symptom**: `bun test file.spec.ts` passes, `bun test` fails.

**Cause**: Cross-file contamination from `mock.module()` in another spec.

**Fix**:

1. Search for `mock.module()` calls that mock the same module
2. Refactor to `spyOn()` pattern with `afterEach` cleanup
3. Verify: Run both tests together

### "Expected to be called but it was not called"

**Symptom**: `expect(mockFn).toHaveBeenCalled()` fails.

**Cause**: Mocking wrong function or wrong mock variable.

**Fix**:

1. Verify spy setup: `spyOn(module, 'correctFunctionName')`
2. Check assertions use mock variable: `expect(mockFn)` not `expect(module.fn)`
3. Verify `beforeEach` creates fresh mocks

### "Hook timed out after 5000ms"

**Symptom**: Test hangs and times out.

**Cause**: Async operation not completed, missing `await`, or unresolved promise.

**Fix**:

1. Ensure all async operations are `await`ed
2. Check mock returns resolved promises: `mockResolvedValue()`
3. Verify no infinite loops in component/hook
4. Increase timeout if legitimately slow: `test('name', fn, 10000)`

## Type Patterns

### Mock Function Types

```typescript
// For mock functions
let mockFn: ReturnType<typeof mock>;

// For spies
let spy: ReturnType<typeof spyOn>;
```

## Red Flags - Cross-Contamination Risk

- Using `mock.module()` outside of preload scripts
- Importing modules directly instead of as namespace for spyOn
- Missing `afterEach()` with `mockRestore()` calls
- Tests passing individually but failing in full suite
- Inconsistent test results between runs
- "Expected to be called" failures when function should have been called

**All of these indicate cross-file contamination. Refactor to spyOn pattern.**

## Common Rationalizations

| Excuse                         | Reality                                           |
| ------------------------------ | ------------------------------------------------- |
| "mock.module() is simpler"     | Causes global contamination. Use spyOn.           |
| "I'll clean up manually"       | Forgetting once breaks tests. Use afterEach.      |
| "I don't need types for mocks" | Type errors and poor DX. Use ReturnType.          |
| "act() is unnecessary noise"   | Prevents warnings and flaky tests. Always use it. |

## Implementation Checklist for Hook Tests

For each new hook test file:

- [ ] All test functions (describe, it, expect, mock, spyOn) are global - no imports needed
- [ ] Import `renderHook`, `act` from `@testing-library/react` when testing hooks
- [ ] Import modules as namespace for spyOn: `import * as module`
- [ ] Declare mock variables with `ReturnType<typeof mock>`
- [ ] Declare spy variables with `ReturnType<typeof spyOn>`
- [ ] Create spies in `beforeEach` with `spyOn(module, 'fn')`
- [ ] Set default mock return values in `beforeEach`
- [ ] **CRITICAL**: Restore spies in `afterEach` with `spy.mockRestore()`
- [ ] Wrap React state changes in `act()`
- [ ] Use mock variables in assertions, not module functions
- [ ] Verify tests pass both individually and in full suite

**If cross-contamination occurs**: Search for `mock.module()` calls, refactor to spyOn, add afterEach cleanup.

## TDD Workflow for Hooks

1. **Red**: Write failing test for hook behavior
2. **Green**: Implement minimal hook code to pass test
3. **Refactor**: Clean up hook implementation
4. **Repeat**: Add next test case

## Plate-Specific Patterns

### Slate Hyperscript JSX Elements

Common elements for test data:

- **Block elements**: `<editor>`, `<hp>`, `<hh1>` through `<hh6>`
- **List elements**: `<hul>`, `<hol>`, `<hli>`
- **Table elements**: `<htable>`, `<htr>`, `<htd>`, `<hth>`
- **Inline elements**: `<ha>`, `<htext bold>`, `<htext italic>`
- **Special elements**: `<hcodeblock>`, `<hblockquote>`, `<hmention>`

```typescript
/** @jsx jsx */

import { jsx } from "@platejs/test-utils";

jsx; // Required

const input = (
  <editor>
    <hp>
      <htext>Hello </htext>
      <htext bold>world</htext>
    </hp>
  </editor>
);
```

### Plugin Testing

```typescript
// Test plugin configuration
const TestPlugin = createSlatePlugin({
  key: "test",
  options: { testOption: "value" },
}).extendEditorApi(() => ({
  testMethod: () => "result",
}));

const editor = createPlateEditor({
  plugins: [TestPlugin],
});

// Test API methods
expect(editor.api.testMethod()).toBe("result");

// Test plugin retrieval
const plugin = editor.getPlugin(TestPlugin);
expect(plugin.options.testOption).toBe("value");
```

### Fragment and Selection Testing

```typescript
// Use cursor and selection markers in JSX
const input = (
  <editor>
    <hp>
      test
      <cursor />
    </hp>
  </editor>
) as any as SlateEditor;

const editor = createPlateEditor({
  selection: input.selection,
  value: input.children,
});
```

### DataTransfer Testing

```typescript
import { createDataTransfer } from "@platejs/test-utils";

// Method 1: Use createDataTransfer utility
const dataTransfer = createDataTransfer(
  new Map([
    ["text/html", "<p>Hello</p>"],
    ["text/plain", "Hello"],
  ])
);

// Method 2: Inline mock
const dataTransfer = {
  constructor: { name: "DataTransfer" },
  getData: (format: string) => format === "text/html" && "<p>Hello</p>",
} as any;

editor.tf.insertData(dataTransfer);
```

### HTML Deserialization Testing

```typescript
import { getHtmlDocument } from "@platejs/test-utils";

const html = "<div>test</div>";
const element = getHtmlDocument(html).body;

const result = deserializeHtml(editor, { element });
expect(result).toEqual(expectedOutput);
```

### Testing with React Testing Library

```typescript
import { render } from "@testing-library/react";

it("should render component", () => {
  const { getByText } = render(<MyComponent />);
  expect(getByText("Expected Text")).toBeTruthy();
});

// For jest-dom matchers, add triple-slash reference
/// <reference types="@testing-library/jest-dom" />
expect(getByText("Hello")).toBeInTheDocument();

// Type assertion workaround for jest-dom matchers
(expect(getByText("Hello")) as any).toBeInTheDocument();

// Query vs Get selectors
const element = queryByTestId("optional"); // Returns null if not found
const element2 = getByTestId("required"); // Throws if not found
```

## Test Organization Patterns

### Grouping Related Tests

```typescript
describe("FeatureName", () => {
  describe("when condition A", () => {
    it("should behavior X", () => {
      // test
    });
  });

  describe("when condition B", () => {
    it("should behavior Y", () => {
      // test
    });
  });
});
```

### Testing Multiple Scenarios

```typescript
// Use describe blocks for different scenarios
describe("when condition is true", () => {
  it("should behave one way", () => {});
});

describe("when condition is false", () => {
  it("should behave another way", () => {});
});

// Skip tests temporarily
it.skip("pending test", () => {});
```

## Best Practices

- Test both positive and negative cases
- Test edge cases and boundary conditions
- Keep tests focused on a single behavior
- Use descriptive test names: "should [expected behavior] when [condition]"
- Avoid testing implementation details
- Test the public API, not internal functions
- Mock external dependencies, not internal functions
- Refer to existing tests in the same package for patterns

## Common Anti-Patterns

```typescript
// ❌ DON'T: Use relative imports in tests
import { myFunction } from "../src/myFunction";

// ✅ DO: Use package imports
import { myFunction } from "@platejs/package-name";

// ❌ DON'T: Test implementation details
expect(privateFunction).toHaveBeenCalled();

// ✅ DO: Test public API behavior
expect(editor.api.publicMethod()).toBe(expectedResult);
```