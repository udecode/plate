/**
 * T095f: Diff Export Example
 *
 * Demonstrates how to export algorithmic diff marks to DOCX track changes.
 * Diff marks are generated by comparing two versions of a document,
 * unlike suggestions which are manually created by users.
 *
 * Diff export uses the same OOXML track change elements (w:ins, w:del)
 * but with a system-generated author and timestamp.
 *
 * This example shows:
 * - Simple text diff export
 * - Paragraph-level diff detection
 * - Configurable diff author metadata
 * - Integration with tracking-bridge diff functions
 */

import {
  Document,
  Paragraph,
  Run,
  Revision,
  RevisionManager,
} from '../../docXMLater/src';

/**
 * Diff operation from a diff algorithm
 */
interface DiffOperation {
  type: 'equal' | 'insert' | 'delete';
  value: string;
}

/**
 * Configuration for diff export
 */
interface DiffExportConfig {
  author: string;
  date: Date;
  /** If true, combine adjacent operations of the same type */
  consolidate: boolean;
}

const DEFAULT_DIFF_CONFIG: DiffExportConfig = {
  author: 'Diff Engine',
  date: new Date(),
  consolidate: true,
};

/**
 * Creates a document from diff operations
 *
 * Takes the output of a diff algorithm and creates a DOCX document
 * with track changes showing what was added/removed.
 */
export function createDocumentFromDiff(
  diffs: DiffOperation[],
  config: Partial<DiffExportConfig> = {}
): { doc: Document; revisionManager: RevisionManager } {
  const fullConfig = { ...DEFAULT_DIFF_CONFIG, ...config };
  const doc = new Document();
  const revisionManager = new RevisionManager();

  const processedDiffs = fullConfig.consolidate
    ? consolidateDiffs(diffs)
    : diffs;

  // Group diffs by paragraph (split on newlines)
  const paragraphGroups = groupDiffsByParagraph(processedDiffs);

  paragraphGroups.forEach((group) => {
    const paragraph = new Paragraph();

    group.forEach((diff) => {
      if (diff.type === 'equal') {
        paragraph.addContent(new Run(diff.value));
      } else if (diff.type === 'insert') {
        const revision = new Revision({
          type: 'insert',
          author: fullConfig.author,
          date: fullConfig.date,
          content: new Run(diff.value),
        });
        revisionManager.register(revision);
        paragraph.addRevision(revision);
      } else if (diff.type === 'delete') {
        const revision = new Revision({
          type: 'delete',
          author: fullConfig.author,
          date: fullConfig.date,
          content: new Run(diff.value),
        });
        revisionManager.register(revision);
        paragraph.addRevision(revision);
      }
    });

    doc.addParagraph(paragraph);
  });

  return { doc, revisionManager };
}

/**
 * Example: Simple text comparison
 *
 * Compares "Hello World" with "Hello Beautiful World" and generates
 * a document with the insertion tracked.
 */
export function createSimpleDiffExample(): {
  doc: Document;
  revisionManager: RevisionManager;
} {
  const diffs: DiffOperation[] = [
    { type: 'equal', value: 'Hello ' },
    { type: 'insert', value: 'Beautiful ' },
    { type: 'equal', value: 'World' },
  ];

  return createDocumentFromDiff(diffs, {
    author: 'Diff Comparison',
    date: new Date('2025-01-15T12:00:00Z'),
  });
}

/**
 * Example: Paragraph replacement diff
 *
 * Shows how a paragraph is rewritten - the old text is deleted
 * and new text is inserted.
 */
export function createParagraphReplacementDiff(): {
  doc: Document;
  revisionManager: RevisionManager;
} {
  const diffs: DiffOperation[] = [
    { type: 'equal', value: 'Chapter 1: ' },
    { type: 'delete', value: 'Getting Started with Basics' },
    { type: 'insert', value: 'Advanced Techniques for Professionals' },
  ];

  return createDocumentFromDiff(diffs, {
    author: 'Version Compare',
    date: new Date('2025-06-15T09:00:00Z'),
  });
}

/**
 * Example: Multi-paragraph diff
 *
 * Shows diff across multiple paragraphs with mixed operations.
 */
export function createMultiParagraphDiff(): {
  doc: Document;
  revisionManager: RevisionManager;
} {
  const diffs: DiffOperation[] = [
    { type: 'equal', value: 'First paragraph remains the same.' },
    { type: 'equal', value: '\n' },
    { type: 'delete', value: 'This old paragraph is removed.' },
    { type: 'equal', value: '\n' },
    { type: 'insert', value: 'This new paragraph is added.' },
    { type: 'equal', value: '\n' },
    { type: 'equal', value: 'Last paragraph ' },
    { type: 'delete', value: 'has minor edits' },
    { type: 'insert', value: 'was slightly modified' },
    { type: 'equal', value: '.' },
  ];

  return createDocumentFromDiff(diffs, {
    author: 'Document Diff Engine',
    date: new Date(),
  });
}

/**
 * Consolidates adjacent diff operations of the same type
 *
 * For example: [insert("a"), insert("b")] becomes [insert("ab")]
 */
export function consolidateDiffs(diffs: DiffOperation[]): DiffOperation[] {
  if (diffs.length === 0) return [];

  const result: DiffOperation[] = [{ ...diffs[0] }];

  for (let i = 1; i < diffs.length; i++) {
    const current = diffs[i];
    const previous = result[result.length - 1];

    if (current.type === previous.type) {
      previous.value += current.value;
    } else {
      result.push({ ...current });
    }
  }

  return result;
}

/**
 * Groups diff operations by paragraph (splits on newline boundaries)
 */
export function groupDiffsByParagraph(
  diffs: DiffOperation[]
): DiffOperation[][] {
  const groups: DiffOperation[][] = [[]];

  diffs.forEach((diff) => {
    if (diff.value === '\n') {
      groups.push([]);
    } else if (diff.value.includes('\n')) {
      // Split multi-line values
      const lines = diff.value.split('\n');
      lines.forEach((line, index) => {
        if (line) {
          groups[groups.length - 1].push({ type: diff.type, value: line });
        }
        if (index < lines.length - 1) {
          groups.push([]);
        }
      });
    } else {
      groups[groups.length - 1].push(diff);
    }
  });

  // Remove empty groups
  return groups.filter((g) => g.length > 0);
}

/**
 * Generates a summary of diff operations for reporting
 */
export function getDiffSummary(diffs: DiffOperation[]): {
  totalOps: number;
  insertions: number;
  deletions: number;
  unchanged: number;
  charsInserted: number;
  charsDeleted: number;
  charsUnchanged: number;
} {
  let insertions = 0;
  let deletions = 0;
  let unchanged = 0;
  let charsInserted = 0;
  let charsDeleted = 0;
  let charsUnchanged = 0;

  diffs.forEach((diff) => {
    const charCount = diff.value.length;
    switch (diff.type) {
      case 'insert':
        insertions++;
        charsInserted += charCount;
        break;
      case 'delete':
        deletions++;
        charsDeleted += charCount;
        break;
      case 'equal':
        unchanged++;
        charsUnchanged += charCount;
        break;
    }
  });

  return {
    totalOps: diffs.length,
    insertions,
    deletions,
    unchanged,
    charsInserted,
    charsDeleted,
    charsUnchanged,
  };
}

/**
 * Simple word-level diff implementation for demonstration
 *
 * In production, use a proper diff library like `diff-match-patch`.
 * This is a simplified version for the example.
 */
export function simpleWordDiff(
  oldText: string,
  newText: string
): DiffOperation[] {
  const oldWords = oldText.split(/(\s+)/);
  const newWords = newText.split(/(\s+)/);
  const ops: DiffOperation[] = [];

  // Simple LCS-based comparison
  let oldIdx = 0;
  let newIdx = 0;

  while (oldIdx < oldWords.length && newIdx < newWords.length) {
    if (oldWords[oldIdx] === newWords[newIdx]) {
      ops.push({ type: 'equal', value: oldWords[oldIdx] });
      oldIdx++;
      newIdx++;
    } else {
      // Check if old word appears later in new
      const newPos = newWords.indexOf(oldWords[oldIdx], newIdx);
      if (newPos !== -1 && newPos - newIdx < 5) {
        // Insert new words before the match
        while (newIdx < newPos) {
          ops.push({ type: 'insert', value: newWords[newIdx] });
          newIdx++;
        }
      } else {
        // Check if new word appears later in old
        const oldPos = oldWords.indexOf(newWords[newIdx], oldIdx);
        if (oldPos !== -1 && oldPos - oldIdx < 5) {
          while (oldIdx < oldPos) {
            ops.push({ type: 'delete', value: oldWords[oldIdx] });
            oldIdx++;
          }
        } else {
          // Replace: delete old, insert new
          ops.push({ type: 'delete', value: oldWords[oldIdx] });
          ops.push({ type: 'insert', value: newWords[newIdx] });
          oldIdx++;
          newIdx++;
        }
      }
    }
  }

  // Remaining old words are deletions
  while (oldIdx < oldWords.length) {
    ops.push({ type: 'delete', value: oldWords[oldIdx] });
    oldIdx++;
  }

  // Remaining new words are insertions
  while (newIdx < newWords.length) {
    ops.push({ type: 'insert', value: newWords[newIdx] });
    newIdx++;
  }

  return consolidateDiffs(ops);
}
