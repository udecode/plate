/**
 * Plugin Bridge - Plugin Architecture for DOCX Export
 *
 * This module provides a flexible plugin system for extending the DOCX export
 * process with custom pre/post processing hooks and export adapters.
 *
 * @module adapters/plugin-bridge
 */

import type { Document } from '../docXMLater/src';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Export plugin context shared across all plugin hooks
 * Provides access to document state and allows plugins to share data
 */
export interface PluginContext {
  /** The Document being exported */
  document: Document;
  /** Original HTML content being converted */
  html: string;
  /** Export options passed to the conversion */
  options: ExportPluginOptions;
  /** Shared data storage for inter-plugin communication */
  sharedData: Map<string, unknown>;
  /** Warnings collected during processing */
  warnings: PluginWarning[];
  /** Statistics collected during processing */
  stats: PluginStats;
}

/**
 * Warning generated by a plugin during processing
 */
export interface PluginWarning {
  /** Plugin that generated the warning */
  pluginId: string;
  /** Warning type */
  type: 'info' | 'warning' | 'error';
  /** Warning message */
  message: string;
  /** Additional context */
  context?: Record<string, unknown>;
}

/**
 * Statistics collected during export processing
 */
export interface PluginStats {
  /** Number of elements processed */
  elementsProcessed: number;
  /** Number of images processed */
  imagesProcessed: number;
  /** Number of tables processed */
  tablesProcessed: number;
  /** Processing time in milliseconds */
  processingTimeMs: number;
  /** Custom stats from plugins */
  custom: Record<string, number>;
}

/**
 * Export plugin options
 */
export interface ExportPluginOptions {
  /** Enable debug logging */
  debug?: boolean;
  /** Custom plugin configuration */
  pluginConfig?: Record<string, unknown>;
}

/**
 * Result of a plugin hook execution
 */
export interface PluginHookResult {
  /** Whether to continue processing (false to abort) */
  continue: boolean;
  /** Modified document (if applicable) */
  document?: Document;
  /** Modified HTML (if applicable) */
  html?: string;
  /** Error message if processing failed */
  error?: string;
}

/**
 * Plugin lifecycle hooks
 */
export interface PluginHooks {
  /**
   * Called before HTML parsing begins
   * Can modify the HTML before it's parsed
   */
  preProcess?: (
    context: PluginContext
  ) => Promise<PluginHookResult> | PluginHookResult;

  /**
   * Called after HTML parsing but before Document conversion
   * Can modify parsed DOM or document options
   */
  preParse?: (
    context: PluginContext,
    dom: unknown
  ) => Promise<PluginHookResult> | PluginHookResult;

  /**
   * Called after each element is processed
   * Can modify or add additional elements
   */
  onElement?: (
    context: PluginContext,
    element: unknown,
    result: unknown
  ) => Promise<void> | void;

  /**
   * Called after Document is fully built
   * Can perform final modifications before serialization
   */
  postProcess?: (
    context: PluginContext
  ) => Promise<PluginHookResult> | PluginHookResult;

  /**
   * Called after Document is saved to buffer
   * Can perform post-export operations
   */
  postExport?: (context: PluginContext, buffer: Buffer) => Promise<void> | void;
}

/**
 * Export plugin definition
 */
export interface ExportPlugin {
  /** Unique plugin identifier */
  id: string;
  /** Human-readable plugin name */
  name: string;
  /** Plugin version */
  version: string;
  /** Plugin description */
  description?: string;
  /** Plugin priority (lower runs first) */
  priority?: number;
  /** Plugin lifecycle hooks */
  hooks: PluginHooks;
  /** Called when plugin is registered */
  initialize?: (registry: PluginRegistry) => void;
  /** Called when plugin is unregistered */
  cleanup?: () => void;
}

/**
 * Element adapter for custom HTML element handling
 */
export interface ElementAdapter {
  /** HTML tag names this adapter handles */
  tags: string[];
  /** Priority (lower runs first) */
  priority?: number;
  /** Handle an element and return DOCX content */
  handle: (
    element: unknown,
    context: PluginContext
  ) => Promise<unknown> | unknown;
}

// ============================================================================
// Plugin Registry
// ============================================================================

/**
 * Registry for managing export plugins and element adapters
 */
export class PluginRegistry {
  private plugins: Map<string, ExportPlugin> = new Map();
  private adapters: Map<string, ElementAdapter[]> = new Map();
  private initialized = false;

  /**
   * Register a plugin with the registry
   * @param plugin - The plugin to register
   * @throws Error if plugin with same ID already exists
   */
  register(plugin: ExportPlugin): void {
    if (this.plugins.has(plugin.id)) {
      throw new Error(`Plugin with ID '${plugin.id}' is already registered`);
    }

    this.plugins.set(plugin.id, plugin);

    // Call plugin initialization hook
    if (plugin.initialize) {
      plugin.initialize(this);
    }
  }

  /**
   * Unregister a plugin from the registry
   * @param pluginId - ID of the plugin to unregister
   */
  unregister(pluginId: string): void {
    const plugin = this.plugins.get(pluginId);
    if (plugin) {
      // Call plugin cleanup hook
      if (plugin.cleanup) {
        plugin.cleanup();
      }
      this.plugins.delete(pluginId);
    }
  }

  /**
   * Get a registered plugin by ID
   * @param pluginId - Plugin ID
   * @returns The plugin or undefined
   */
  getPlugin(pluginId: string): ExportPlugin | undefined {
    return this.plugins.get(pluginId);
  }

  /**
   * Get all registered plugins sorted by priority
   * @returns Array of plugins sorted by priority (lower first)
   */
  getPlugins(): ExportPlugin[] {
    return Array.from(this.plugins.values()).sort(
      (a, b) => (a.priority ?? 100) - (b.priority ?? 100)
    );
  }

  /**
   * Register an element adapter
   * @param adapter - The adapter to register
   */
  registerAdapter(adapter: ElementAdapter): void {
    for (const tag of adapter.tags) {
      const tagLower = tag.toLowerCase();
      if (!this.adapters.has(tagLower)) {
        this.adapters.set(tagLower, []);
      }
      this.adapters.get(tagLower)!.push(adapter);
      // Sort by priority
      this.adapters
        .get(tagLower)!
        .sort((a, b) => (a.priority ?? 100) - (b.priority ?? 100));
    }
  }

  /**
   * Get adapters for a specific HTML tag
   * @param tag - HTML tag name
   * @returns Array of adapters for this tag
   */
  getAdaptersForTag(tag: string): ElementAdapter[] {
    return this.adapters.get(tag.toLowerCase()) ?? [];
  }

  /**
   * Clear all plugins and adapters
   */
  clear(): void {
    // Cleanup all plugins
    for (const plugin of Array.from(this.plugins.values())) {
      if (plugin.cleanup) {
        plugin.cleanup();
      }
    }
    this.plugins.clear();
    this.adapters.clear();
  }

  /**
   * Check if registry has any plugins
   */
  hasPlugins(): boolean {
    return this.plugins.size > 0;
  }

  /**
   * Get count of registered plugins
   */
  get pluginCount(): number {
    return this.plugins.size;
  }

  /**
   * Get count of registered adapters
   */
  get adapterCount(): number {
    let count = 0;
    for (const adapters of Array.from(this.adapters.values())) {
      count += adapters.length;
    }
    return count;
  }
}

// ============================================================================
// Plugin Executor
// ============================================================================

/**
 * Executes plugin hooks in the correct order
 */
export class PluginExecutor {
  constructor(private registry: PluginRegistry) {}

  /**
   * Create a new plugin context
   */
  createContext(
    document: Document,
    html: string,
    options: ExportPluginOptions = {}
  ): PluginContext {
    return {
      document,
      html,
      options,
      sharedData: new Map(),
      warnings: [],
      stats: {
        elementsProcessed: 0,
        imagesProcessed: 0,
        tablesProcessed: 0,
        processingTimeMs: 0,
        custom: {},
      },
    };
  }

  /**
   * Execute preProcess hooks for all plugins
   */
  async executePreProcess(context: PluginContext): Promise<PluginHookResult> {
    const plugins = this.registry.getPlugins();

    for (const plugin of plugins) {
      if (plugin.hooks.preProcess) {
        const result = await plugin.hooks.preProcess(context);
        if (!result.continue) {
          return result;
        }
        // Update context with any modifications
        if (result.html) {
          context.html = result.html;
        }
      }
    }

    return { continue: true };
  }

  /**
   * Execute preParse hooks for all plugins
   */
  async executePreParse(
    context: PluginContext,
    dom: unknown
  ): Promise<PluginHookResult> {
    const plugins = this.registry.getPlugins();

    for (const plugin of plugins) {
      if (plugin.hooks.preParse) {
        const result = await plugin.hooks.preParse(context, dom);
        if (!result.continue) {
          return result;
        }
      }
    }

    return { continue: true };
  }

  /**
   * Execute onElement hooks for all plugins
   */
  async executeOnElement(
    context: PluginContext,
    element: unknown,
    result: unknown
  ): Promise<void> {
    const plugins = this.registry.getPlugins();

    for (const plugin of plugins) {
      if (plugin.hooks.onElement) {
        await plugin.hooks.onElement(context, element, result);
      }
    }
  }

  /**
   * Execute postProcess hooks for all plugins
   */
  async executePostProcess(context: PluginContext): Promise<PluginHookResult> {
    const plugins = this.registry.getPlugins();

    for (const plugin of plugins) {
      if (plugin.hooks.postProcess) {
        const result = await plugin.hooks.postProcess(context);
        if (!result.continue) {
          return result;
        }
        // Update context document with any modifications
        if (result.document) {
          context.document = result.document;
        }
      }
    }

    return { continue: true };
  }

  /**
   * Execute postExport hooks for all plugins
   */
  async executePostExport(
    context: PluginContext,
    buffer: Buffer
  ): Promise<void> {
    const plugins = this.registry.getPlugins();

    for (const plugin of plugins) {
      if (plugin.hooks.postExport) {
        await plugin.hooks.postExport(context, buffer);
      }
    }
  }
}

// ============================================================================
// Global Registry Instance
// ============================================================================

/**
 * Global plugin registry instance
 * Use this for application-wide plugin registration
 */
export const globalPluginRegistry = new PluginRegistry();

/**
 * Create a scoped plugin registry
 * Useful for isolated plugin contexts
 */
export function createPluginRegistry(): PluginRegistry {
  return new PluginRegistry();
}

/**
 * Create a plugin executor for a registry
 */
export function createPluginExecutor(
  registry: PluginRegistry = globalPluginRegistry
): PluginExecutor {
  return new PluginExecutor(registry);
}
