import {
  type TEditor,
  type TSelection,
  getEndPoint,
  getStartPoint,
  normalizeEditor,
  select,
} from '@udecode/slate';

import type { PlateEditor } from '../../shared/types/PlateEditor';

import {
  type AnyPlatePlugin,
  type GetCorePluginsOptions,
  type PlatePlugins,
  createPlugin,
  getCorePlugins,
  pipeNormalizeInitialValue,
} from '../../shared';
import { resetEditor } from '../../shared/transforms';
import { resolvePlugins } from '../../shared/utils/resolvePlugins';
import { ReactPlugin } from './react';

const shouldHaveBeenOverridden = (fnName: string) => () => {
  console.warn(
    `editor.${fnName} should have been overriden but was not. Please report this issue here: https://github.com/udecode/plate/issues`
  );
};

export type WithPlateOptions<E extends PlateEditor = PlateEditor> = {
  /**
   * Select the editor after initialization.
   *
   * @default false
   *
   * - `true` | 'end': Select the end of the editor
   * - `false`: Do not select anything
   * - `'start'`: Select the start of the editor
   */
  autoSelect?: 'end' | 'start' | boolean;

  children?: E['children'];

  id?: any;

  plugins?: PlatePlugins;

  /** Function to configure the root plugin */
  rootPlugin?: (plugin: AnyPlatePlugin) => AnyPlatePlugin;

  selection?: TSelection;

  /**
   * When `true`, it will normalize the initial `value` passed to the `editor`.
   * This is useful when adding normalization rules on already existing
   * content.
   *
   * @default false
   */
  shouldNormalizeEditor?: boolean;
} & GetCorePluginsOptions &
  Pick<
    Partial<AnyPlatePlugin>,
    | 'api'
    | 'decorate'
    | 'handlers'
    | 'inject'
    | 'normalizeInitialValue'
    | 'options'
    | 'override'
    | 'renderAboveEditable'
    | 'renderAboveSlate'
    | 'renderAfterEditable'
    | 'renderBeforeEditable'
    | 'transforms'
    | 'useHooks'
    | 'withOverrides'
  >;

/**
 * Apply `withInlineVoid` and all plate plugins `withOverrides`. Overrides:
 *
 * - `id`: id of the editor.
 * - `key`: random key for the <Slate> component so each time the editor is
 *   created, the component resets.
 * - `options`: Plate options
 */
export const withPlate = <E extends PlateEditor = PlateEditor>(
  e: TEditor,
  {
    autoSelect,
    children,
    id,
    maxLength,
    plugins = [],
    rootPlugin,
    selection,
    shouldNormalizeEditor,
    ...pluginConfig
  }: WithPlateOptions<E> = {}
): E => {
  const editor = e as E;

  // Override incremental id generated by slate
  editor.id = id ?? editor.id;
  editor.prevSelection = null;
  editor.isFallback = false;
  editor.currentKeyboardEvent = null;

  // Editor methods
  editor.reset = () => resetEditor(editor);
  editor.redecorate = () => shouldHaveBeenOverridden('redecorate');
  editor.plate = {
    get set() {
      shouldHaveBeenOverridden('plate.set');

      return null as any;
    },
  };

  if (!editor.key) {
    editor.key = Math.random();
  }

  const corePlugins = getCorePlugins({
    maxLength,
    reactPlugin: ReactPlugin,
  }).filter((p) => !editor.pluginsByKey?.[p.key]);

  let rootPluginInstance = createPlugin({
    key: 'root',
    priority: 10_000,
    ...pluginConfig,
    plugins: [...corePlugins, ...plugins],
  });

  // Apply rootPlugin configuration if provided
  if (rootPlugin) {
    rootPluginInstance = rootPlugin(rootPluginInstance) as any;
  }

  resolvePlugins(editor, [rootPluginInstance]);

  if (children) {
    editor.children = children;
  }
  if (editor.children?.length === 0) {
    editor.children = editor.childrenFactory();
  }
  if (selection) {
    editor.selection = selection;
  } else if (autoSelect) {
    const edge = autoSelect === 'start' ? 'start' : 'end';
    const target =
      edge === 'start' ? getStartPoint(editor, []) : getEndPoint(editor, []);
    select(editor, target);
  }
  if (children) {
    pipeNormalizeInitialValue(editor);
  }
  if (shouldNormalizeEditor) {
    normalizeEditor(editor, { force: true });
  }

  return editor;
};
